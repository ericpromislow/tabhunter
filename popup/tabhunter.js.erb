// tabhunter.js -- See LICENSE.txt for copyright and license details. 

var thMainFunc = (function() {

var items = [];
var selectedIndex;    // visible
var lastClickedIndex; // visible
var matchedItems;
var tablist;
var mainPattern;
var textarea;
var showElapsedTimes = false; // Need a way to enable this.
var t1, t2;
var closeTabsButton;
var matchCloseTabs;
var showAudioButton;
var hideDiscardedTabsButton;
var moveToWindowButton;
var discardTabsButton;
var activateTabsButton;
var hasDiscardedTabs;
var selectWindowTargetWidget;
var finishMoveToWindowButton;
<% if ENV['TARGET'] == 'firefox' %>
var selectBookmarkTargetWidget;
var finishMoveToBookmarkButton;
var g_bookmarkList = null;
<% end %>
var g_showAudio;
var g_hideDiscardTabs;
var g_activeTab;
var g_windowInfoArray;
<% if ENV['TARGET'] == 'chrome' %>
var g_itemSupportsLastAccessed = null;
<% end %>
var closeOnGo = true;
var sortBy = null;
var sortByReverse = false;
var controlVisitN = false;
var g_currentDragTarget = null, g_currentDragTargetClassName = null;
var g_currentItemHeight = null;
const DEFAULT_BASE_FONT_SIZE = 12;

function init() {
    var list = document.getElementById("list");
    mainPattern = document.getElementById("pattern");
    textarea = document.getElementById("textarea");
    g_activeTab = -1;

    tablist = list;

    mainPattern.addEventListener("input", onPatternChanged, false);
    document.addEventListener("keydown", processArrowKey, false);
    document.getElementById("go").addEventListener("mouseup", doGoButton, false);
    closeTabsButton = document.getElementById("closeTabs");
    closeTabsButton.addEventListener("mouseup", doCloseTabsButton, false);
    document.getElementById("copyURL").addEventListener("mouseup", doCopyURLButton, false);
    document.getElementById("copyTitle").addEventListener("mouseup", doCopyTitleButton, false);
    document.getElementById("copyURLTitle").addEventListener("mouseup", doCopyURLTitleButton, false);
    
    showAudioButton = document.getElementById("showAudio");
    showAudioButton.addEventListener("click", doHandleAudioCheckbox, false);
    g_showAudio = showAudioButton.checked;
    
    hideDiscardedTabsButton = document.getElementById("hideDiscardedTabs");
    hideDiscardedTabsButton.addEventListener("click", doHideDiscardedTabsCheckbox, false);
    g_hideDiscardTabs = hideDiscardedTabsButton.checked;
    hasDiscardedTabs = false;
    
    moveToWindowButton = document.getElementById("moveToWindow");
    moveToWindowButton.addEventListener("mouseup", showWindowMover, false);

    discardTabsButton = document.getElementById("discardSelectedTabs");
    discardTabsButton.addEventListener("mouseup", discardTheTabs, false);
    activateTabsButton = document.getElementById("activateSelectedTabs");
    activateTabsButton.addEventListener("mouseup", activateTheTabs, false);

    selectWindowTargetWidget = document.getElementById("windowList");
    finishMoveToWindowButton = document.getElementById("doMoveToWindow");
    finishMoveToWindowButton.addEventListener("mouseup", doMoveToWindowButton, false);
<% if ENV['TARGET'] == 'firefox' %>
    selectBookmarkTargetWidget = document.getElementById("bookmarkList");
    finishMoveToBookmarkButton = document.getElementById("doMoveToBookmark");
    finishMoveToBookmarkButton.addEventListener("mouseup", doMoveToBookmarkButton, false);
<% end %>

    matchCloseTabs = /^(.*?)(s?)$/;

    $("button").mouseover(doMouseOver);
    $("button").mouseout(doMouseOut);
    $("button").mousedown(doMouseDown);
    $("button").mouseup(doMouseUp);

    var gotPatternOK = function(item) {
        if ('pattern' in item) {
            mainPattern.value = item.pattern;
        } else {
            mainPattern.value = '';
        }
        selectPattern();
        restoreAudioSetting();
    };
    var gotPatternErr = function(err) {
        restoreAudioSetting();
    };
    browser.storage.local.get("pattern").then(gotPatternOK, gotPatternErr);
}

function selectPattern() {
    mainPattern.focus();
    if (mainPattern.value) {
        mainPattern.select();
    }
}

function restoreAudioSetting() {
    var gotSettingOK = function(item) {
        if ('showAudio' in item) {
            g_showAudio = item.showAudio;
            showAudioButton.checked = g_showAudio;
        }
        if ('hideDiscardTabs' in item) {
            g_hideDiscardTabs = item.hideDiscardTabs;
            hideDiscardedTabsButton.checked = g_hideDiscardTabs;
        }
        restoreHideAudioSetting();
    };
    var gotSettingErr = function(err) {
        restoreHideAudioSetting();
    };
    browser.storage.local.get("showAudio").then(gotSettingOK, gotSettingErr);
}

function restoreHideAudioSetting() {
    var gotSettingOK = function(item) {
        if ('hideDiscardTabs' in item) {
            g_hideDiscardTabs = item.hideDiscardTabs;
            hideDiscardedTabsButton.checked = g_hideDiscardTabs;
        }
        getCloseOnGoPref();
    };
    var gotSettingErr = function(err) {
        populateTabList();
    };
    browser.storage.local.get("hideDiscardTabs").then(gotSettingOK, gotSettingErr);
}

function depx(pref) {
    let p = /^(\d+).*/;
    let m = p.exec(pref);
    if (m) {
        return parseInt(m[1], 10);
    }
    return parseInt(pref, 10);
}

function px(size) {
    return `${size}px`;
}

function getCloseOnGoPref() {
    let gotPrefOK = function(item) {
        let prefs = item["prefs"];
        if (prefs && 'sortBy' in prefs) {
            sortBy = comparisonFunctions[prefs['sortBy']];
        }
        if (!sortBy) {
            sortBy = comparisonFunctions['Title'];
        }
        if (prefs && 'sortByReverse' in prefs) {
            sortByReverse = !!prefs['sortByReverse'];
        }
        if (prefs && 'controlVisitN' in prefs) {
            controlVisitN = !!prefs['controlVisitN'];
            if (controlVisitN) {
                document.addEventListener("keyup", processKey, false);
            }
        }
        if (prefs && 'fontSize' in prefs) {
            let baseFontSize = depx(prefs['fontSize']) || DEFAULT_BASE_FONT_SIZE;
            list.style.fontSize = px(baseFontSize);
            $('body').css('font-size', px(baseFontSize + 1));
            $('label.text').css('font-size', px(baseFontSize));
            $('label.checkbox').css('font-size', px(baseFontSize - 1));
            $('div#buttons.button').css('font-size', px(baseFontSize - 1));
            $('ul#list').css('font-size', px(baseFontSize));
            $('span#activity').css('font-size', px(baseFontSize + 1));
        }
        if (prefs && "closeOnGo" in prefs) {
            closeOnGo = prefs["closeOnGo"];
        } else {
            closeOnGo = null;
        }
        if (closeOnGo !== true && closeOnGo !== false) {
            closeOnGo = true;
            let continueFuncOK = function() {
                populateTabList();
            };
            let continueFuncErr = function(err) {
                populateTabList();
            };
            
            browser.storage.local.set({"closeOnGo": closeOnGo}).then(continueFuncOK, continueFuncErr);
        } else {
            populateTabList();
        }
    };
    let gotPrefErr = function(err) {
        console.log(`tabhunter: getCloseOnGoPref.gotPrefErr: err: ${err}`);
        populateTabList();
    };
    browser.storage.local.get().then(gotPrefOK, gotPrefErr);
}

function WindowIndexThing() {
    this.currentIndex = 0;
    this.indicesByID = {};
}
WindowIndexThing.prototype = {
    intern: function(windowID) {
        if (windowID in this.indicesByID) {
            return this.indicesByID[windowID];
        }
        this.currentIndex += 1;
        this.indicesByID[windowID] = this.currentIndex;
        return this.currentIndex;
    },
    index: function(windowID) {
        return this.indicesByID[windowID];
    },
    __EOT__: null
}
var windowCounter = new WindowIndexThing();

// Tabs: save [title, url, window#id, tab#id, tab#index, tab#favIconUrl, tab#audible] 
function makeTabItem(id, tab) {
    windowCounter.intern(id);
    return {
      title: tab.title,
      url: tab.url,
      windowID: id,
      tabID: tab.id,
      tabIndex: tab.index,
      favIconUrl: tab.favIconUrl,
      lastAccessed: tab.lastAccessed,
      discarded: tab.discarded,
      audible: tab.audible
    };
}

function isForbiddenFavIconUrl(url) {
    return ['chrome://mozapps/skin/extensions/extensionGeneric-16.svg',
           'chrome://mozapps/skin/extensions/extensionGeneric-16.png'].indexOf(url) >= 0;
}

function subCompareByKey(tab1, tab2, key) {
    let s1 = tab1[key].toLowerCase();
    let s2 = tab2[key].toLowerCase();
    if (s1 < s2) return -1;
    if (s1 > s2) return 1;
    return 0;
}

function compareByTitle(tab1, tab2) {
    let res = subCompareByKey(tab1, tab2, 'title');
    if (res != 0) return res;
    res = subCompareByKey(tab1, tab2, 'url');
    if (res != 0) return res;
    return compareByWindowTab(tab1, tab2);
}

function compareByURL(tab1, tab2) {
    let res = subCompareByKey(tab1, tab2, 'url');
    if (res != 0) return res;
    res = subCompareByKey(tab1, tab2, 'title');
    if (res != 0) return res;
    return compareByWindowTab(tab1, tab2);
}

function compareByNeglect(tab1, tab2) {
    let res = tab1.lastAccessed - tab2.lastAccessed;
    if (res != 0) return res;
    return compareByTitle(tab1, tab2);
}

function compareByWindowTab(tab1, tab2) {
    let windowID1 = tab1.windowID;
    let windowID2 = tab2.windowID;
    if (windowID1 < windowID2) return -1;
    if (windowID1 > windowID2) return 1;
    let tabIndex1 = tab1.tabIndex;
    let tabIndex2 = tab2.tabIndex;
    return tabIndex1 - tabIndex2;
}

const comparisonFunctions = {'Title': compareByTitle,
                             'URL': compareByURL,
                             'Neglect': compareByNeglect,
                             'Position': compareByWindowTab};

function sortByWithReverseCheck(tab1, tab2) {
    var negateResult = sortByReverse ? -1 : 1;
    var res = sortBy(tab1, tab2);
    return res * negateResult;
    // return (sortByReverse ? -1 : 1) * sortBy(tab1, tab2);
}

function getReadableAge(ts) {
    let age = (new Date().valueOf() - ts) / 1000;  // sec
    if (age < 60) {
        return `${Math.round(age)} sec`;
    }
    age /= 60; // mins.
    if (age < 60) {
        return `${Math.round(age)} min`;
    }
    age /= 60; // hours.
    if (age < 24) {
        return `${Math.round(age)} hr`;
    }
    age /= 24; // days.
    if (age <= 60) {
        return pluralize(Math.round(age), 'day');
    }
    if (age <= 366) {
        return `${Math.round(age / 7)} weeks`;
    }
    let daysPerMonth = 365.25 / 12;
    let months = Math.round(age / daysPerMonth);
    if (months < 12) {
	return `${pluralize(months, 'mo')}`;
    }
    let years = Math.floor(months / 12);
    months = months % 12;
    if (months > 0) {
        return `${pluralize(years, 'yr')} ${pluralize(months, 'mo')}`;
    }
    return `${pluralize(years, 'yr')}`;
}

function pluralize(amt, term) {
    var suffix = (amt == 1) ? "" : "s";
    return `${amt} ${term}${suffix}`;
}

function populateTabList() {
    selectedIndex = 0;
    lastClickedIndex = -1;
    g_currentItemHeight = null;
    matchedItems = [];
    const getAllProperties = {populate: true, windowTypes: ['normal']}
    const endTime = function(cmd) {
        t2 = (new Date()).valueOf();
        //console.log("Elapsed time to " + cmd + ": " + ((t2 - t1)/1000) + " msec");
    }
    const errGetAllWindows = function(err) {
        if (showElapsedTimes) {
            endTime("getting windows");
        }
        console.log(`tabhunter: errGetAllWindows: err: ${err}`);
    }
    
    const doGetAllWindows = function (windowInfoArray) {
        g_windowInfoArray = windowInfoArray;
        if (showElapsedTimes) {
            endTime("getting " + (windowInfoArray.length) + " windows");
            t1 = (new Date()).valueOf();
        }
        items.splice(0); // clear
        //TODO: Use a heap array to make building a sorted list one item at a time
        // an n . lg(n) operation
        for (var windowInfo of windowInfoArray) {
            var id = windowInfo.id;
            var tabs = windowInfo.tabs;
            for (var tab of tabs) {
                if (tab.active && windowInfo.focused) {
                    g_activeTab = tab.id;
                }
                // Tabs: save [title, url, window#id, tab#id, tab#index, tab#favIconUrl
                items.push(makeTabItem(id, tab));
            }
        }
        if (showElapsedTimes) {
            endTime("getting tabs");
            t1 = (new Date()).valueOf();
        }
        items.sort(sortByWithReverseCheck);
        
        if (showElapsedTimes) {
            endTime("sorting tabs");
            t1 = (new Date()).valueOf();
        }
        onPatternChanged(null, true);
        
        if (showElapsedTimes) {
            endTime("setting matched tabs");
        }
        // Need to do this in a setTimeout of 100 msec for reasons unknown
        setTimeout(function() {
            try {
                selectPattern();
            } catch(e) {
                console.log("tabhunter: * mainPattern.focus(): " + e);
            }
        }, 100);
    };
    t1 = (new Date()).valueOf();
    // Load all the tabs each time we show the popup.
    //TODO: Maintain the tab list in the background processor, so we can show
    // them faster here.

    browser.windows.getAll(getAllProperties).then(doGetAllWindows, errGetAllWindows);
}

function doMouseOver(eventData) {
    if (!eventData.currentTarget.disabled) {
        $(this).addClass("highlighted");
    }
}

function doMouseOut(eventData) {
    $(this).removeClass("highlighted");
    $(this).removeClass("pressed");
}

function doMouseDown(eventData) {
    if (!eventData.currentTarget.disabled) {
        $(this).addClass("pressed");
    }
}

function doMouseUp(eventData) {
    $(this).removeClass("pressed");
}

function doVisitSelectedURL() {
    if (selectedIndex < 0 || selectedIndex >= matchedItems.length) {
        return;
    }
    var target = items[matchedItems[selectedIndex]];
    // target: tab.title, tab.url, window.id, tab.id, tab.index
    var windowId = target.windowID;
    var tabId = target.tabID;

    const getCurrentErr = function(err) {
        console.log("tabhunter: Error getting current window: " + err);
    };
    const getCurrentCont = function(windowInfo) {
        if (windowInfo.id != windowId) {
            const showWindowErr = function(err) {
                console.log("tabhunter: Error showing current window: " + err);
            };
            const showWindowCont = function(windowInfo) {
                if (closeOnGo) {
                    close();
                }
            }
            const updateInfo = { focused: true, drawAttention: true, state: "normal" };
            browser.windows.update(target.windowID, updateInfo).then(showWindowCont, showWindowErr);
        } else {
            if (closeOnGo) {
                close();
            }
        }
    };

    const showTabErr = function(err) {
        console.log("tabhunter: Error showing tab id " + tabId + ": " + err);
    };
    const showTabCont = function(tab) {
        browser.windows.getCurrent().then(getCurrentCont, getCurrentErr);
    };
    const showTab = function() {
        var updateProperties = {active: true} ; // firefox doesn't do:, selected: true}
        browser.tabs.update(tabId, updateProperties).then(showTabCont, showTabErr);
    };
    showTab();
}

function processArrowKey(event) {
    try {
        processArrowKey_aux(event);
    } catch(e) {
        console.log("tabhunter: *** processArrowKey: awp: " + e);
    }
}

function processKey(event) {
    try {
        var mask = getModifierMask(event);
        var keyName = event.key;
        if (keyName == "Control") {
            return;
        }
        if ((mask & CTRL_KEY) == CTRL_KEY && keyName >= '1' && keyName <= '9') {
            let keyValue = parseInt(keyName, 10);
            if (keyValue <= matchedItems.length) {
                selectedIndex = keyValue - 1;
                doVisitSelectedURL();
                event.stopPropagation();
                event.preventDefault();
                return;
            }
        }
    } catch(e) {
        console.log("tabhunter: *** processKey: awp: " + e);
    }
}

const SHIFT_KEY = 1;
const CTRL_KEY = 2;
const ALT_KEY = 4;

function processArrowKey_aux(event) {
    var mask = getModifierMask(event);

    var selectedItems = getSelectedItemsJQ();
    var keyName = event.key;
    if (keyName == "Enter") {
        if (mask != 0) {
            console.log("tabhunter: Enter can't be modified with shift, etc.");
        } else {
            if (selectedItems.length > 1) {
                // Keep existing behavior
                selectedIndex = selectedItems[0].actualIndex;
            } 
            doVisitSelectedURL();
        }
        event.stopPropagation();
        event.preventDefault();
        return;
    }
    var newSelectedIndex;
    if (keyName == "ArrowUp") {
        if (selectedIndex <= 0) {
            return;
        }
        newSelectedIndex = selectedIndex - 1;
    } else if (keyName == "ArrowDown") {
        if (selectedIndex >= matchedItems.length - 1) {
            return;
        }
        newSelectedIndex = selectedIndex + 1;
    } else {
        return;
    }
    var li = tablist.childNodes[newSelectedIndex];
    if ((mask & SHIFT_KEY) != SHIFT_KEY) {
        $("ul li").removeClass('selected');
    }
    if (li.addClass) {
        li.classList.addClass("selected");
    } else {
        li.setAttribute("class", "selected");
    }
    selectedIndex = newSelectedIndex;
    var url = document.getElementById("url");
    url.value = items[matchedItems[selectedIndex]].url;
}

function onListItemClick(event) {
    var i = event.target.visibleIndex;
    var mask = getModifierMask(event);
    
    if (mask == SHIFT_KEY && lastClickedIndex > -1) {
        selectRange(lastClickedIndex, i);
    } else if (mask == CTRL_KEY) {
        $(this).toggleClass('selected');
    } else {
        $("ul li").removeClass('selected');
        $(this).addClass('selected');
    }
    selectedIndex = i;
    lastClickedIndex = (mask & (SHIFT_KEY|CTRL_KEY)) == 0 ? i : -1;
    document.getElementById("url").value = items[matchedItems[i]].url;
    updateButtons();
}

function selectRange(lastClickedIndex, currentIndex) {
    if (lastClickedIndex > currentIndex) {
        [lastClickedIndex, currentIndex] = [currentIndex, lastClickedIndex];
    }
    for (var i = lastClickedIndex; i <= currentIndex; i++) {
        tablist.childNodes[i].setAttribute("class", "selected");
    }
}

function onListItemDoubleClick() {
    doVisitSelectedURL();
}

function allowAll() {
    return true;
}

function onPatternChanged(event, calledFromInit) {
    if (typeof(calledFromInit) == undefined) calledFromInit = false;
    matchedItems = [];
    var pattern = mainPattern.value;
    var ptn;
    var fn, winFnParts = [];
    browser.storage.local.set({"pattern": pattern});
    if (pattern.length == 0) {
        fn = allowAll;
    } else {
        // If the pattern starts with a window-selector, handle it
        let p = /^\{w:?(\d+)(?::([-\d]+))?\}(.*)$/;
        let m = p.exec(pattern);
        if (m) {
            let winNum = parseInt(m[1], 10);
            winFnParts.push(function(item) {
                return windowCounter.index(item.windowID) == winNum;
            });
            if (m[2] !== undefined) {
                let [startTabNum, endTabNum] = m[2].split('-', 2);
                if (endTabNum.indexOf('-') >= 0) {
                    console.log('Tabhunter: at most one dash allowed in a tab list');
                    //TODO: Write out an error message
                    winFnParts.push(function(item) {
                        return false;
                    });
                }
                if (startTabNum != "") {
                    startTabNum = parseInt(startTabNum, 10) - 1;
                    winFnParts.push(function(item) {
                        return item.tabIndex >= startTabNum
                    });
                }
                if (endTabNum != "") {
                    endTabNum = parseInt(endTabNum, 10) - 1;
                    winFnParts.push(function(item) {
                        return item.tabIndex <= endTabNum
                    });
                }
            }
            pattern = m[3];
        }
        try {
            if (/[A-Z]/.test(pattern) && /[a-z]/.test(pattern)) {
                // If they specify both cases, don't ignore case.
                ptn = new RegExp(pattern);
            } else {
                ptn = new RegExp(pattern, "i");
            }
            fn = function matchPtn(item) {
                return ptn.test(item.title) || ptn.test(item.url);
            }
        } catch(ex) {
            console.log("tabhunter: not a valid javascript pattern: " + ex);
            // just do a case-insensitive substring search
            ptn = pattern.toLowerCase();
            fn = function matchText(item) {
                return (item.title.toLowerCase().indexOf(ptn) >= 0
                        || item.url.toLowerCase().indexOf(ptn) >= 0);
            }
        }
    }
    for (var i = 0; i < items.length; i++) {
        // if (!winFnParts.every(function(f) { return f(); })) { }
        let item = items[i];
        if ((!winFnParts.every((f) => f(item)))
            || (g_showAudio && !item.audible)) {
            continue;
        }
        if (item.discarded) {
            hasDiscardedTabs = true;
            if (g_hideDiscardTabs) {
                continue;
            }
        }
        if (fn(item)) {
            matchedItems.push(i);
        }
    }
    if (calledFromInit && g_showAudio && matchedItems.length == 0 && pattern == "") {
        // This can only be called once this way
        showAudioButton.checked = g_showAudio = false;
        // setTimeout to allow the button to get checked before the code continues.
        setTimeout(onPatternChanged, 10, null, false);
        return;
    }
    makeListFromMatchedItems();
}

function setStatusBarMessage(msg) {
    $("div#statusbar").removeClass("hide").addClass("show");
    $("p#statusbar-p").text(msg);
    setTimeout(function() {
        $("div#statusbar").removeClass("show").addClass("hide");
        $("p#statusbar-p").text("");
    }, 30* 1000);
}

function makeListFromMatchedItems() {
    var selectedItems = getSelectedItemsJQ();
    var selectedActualIndices = selectedItems.map(function(elt) { return elt.actualIndex });
    var lastClickedActualIndex = matchedItems[lastClickedIndex];
    var selectedActualIndex = matchedItems[selectedIndex];
    $("#list").empty();
    $("ul li").off("dblclick", onListItemDoubleClick);
    $("ul li").off("click", onListItemClick);
    selectedIndex = 0;
    lastClickedIndex = -1;
<% if ENV['TARGET'] == 'chrome' %>
    if (sortBy == compareByNeglect && g_itemSupportsLastAccessed === null && items.length > 0) {
        g_itemSupportsLastAccessed = (items[0].lastAccessed !== undefined);
    }
<% end %>
    for (var i = 0; i < matchedItems.length; i++) {
        var idx = matchedItems[i];
        var item = items[idx];
        var el = document.createElement("li");
        if (sortBy == compareByWindowTab) {
            // Add 1 because not all tabhunter users are proggers
            el.textContent = `[${windowCounter.index(item.windowID)}:${item.tabIndex + 1}] `;
        } else {
            el.textContent = '';
        }
        el.textContent += item.title + " - " + item.url;
        if (sortBy == compareByNeglect
<% if ENV['TARGET'] == 'chrome' %>
            && g_itemSupportsLastAccessed
<% end %>
            ) {
            el.textContent += ` [${getReadableAge(item.lastAccessed)}]`;
        }
        el.visibleIndex = i;
        el.actualIndex = idx;
        if (item.favIconUrl && !isForbiddenFavIconUrl(item.favIconUrl)) {
            el.style.backgroundImage = "url(" + item.favIconUrl + ")";
        }
        if (selectedActualIndices.indexOf(idx) >= 0) {
            $(el).addClass("selected");
            if (idx == selectedActualIndex) {
                selectedIndex = i;
            }
        }
        if (lastClickedIndex > -1 && idx == lastClickedActualIndex) {
            lastClickedIndex = i;
        }
        if (i > 0) {
            let prevIdx = matchedItems[i - 1];
            let prevItem = items[prevIdx];
            // Tabs might have url='about:blank' if they're neglected and
            // haven't been reloaded after a restart...
            if (prevItem.url == item.url && prevItem.title == item.title) {
                $(el).addClass("duplicate");
                el.textContent = el.textContent + " [DUP]";
            }
        }
        if (item.discarded) {
            $(el).addClass("discarded");
        }
        if (sortBy == compareByWindowTab) {
            $(el).attr("draggable", true);
        }
        tablist.appendChild(el);
    }
    if (sortBy == compareByWindowTab) {
        $(tablist).attr("draggable", true);
        tablist.addEventListener("dragstart", onTablistDragStartHandler, true);
        tablist.addEventListener("dragover", onTablistDragOver, true);
        tablist.addEventListener("drop", onTablistDropHandler, false);
    }
    $("ul li:eq(" + selectedIndex + ")").select();
    $("ul li").on("click", onListItemClick);
    $("ul li").on("dblclick", onListItemDoubleClick);
    updateActivity();
    updateURL();
    updateButtons();
}

function getSelectedItemsJQ() {
    return $("ul#list li.selected").toArray();
}

function onTablistDragStartHandler(event) {
    try {
        var selectedItems = getSelectedItemsJQ();
        if (selectedItems.length == 0) {
            return;
        }
        //event.preventDefault();
        var tabIds = [], urls = [];
        selectedItems.forEach(function(selectedItem) {
                let item = items[selectedItem.actualIndex];
                tabIds.push(item.tabID);
                urls.push(item.url);
            });
        // Add the drag data
        event.dataTransfer.setData("text/plain", tabIds.join(","));
        event.dataTransfer.setData("text/uri-list", urls.join("\n"));
    } catch(ex) {
        console.log(`tabhunter: error on drag/drop start handler: ${ex}`);
    }
}

function getDropIndexWithTabInfo(event) {
    let [actualIndex, targetNode] = getDropIndex(event);
    if (actualIndex === null || targetNode === undefined) {
        return [actualIndex, targetNode, undefined];
    }
    let actualListItem = null, fixedTabIndex = 0, actualTab;
    if (sortByReverse) {
        // Gravity flows up in this case
        if (actualIndex == -1) {
            actualListItem = tablist.lastChild;
            actualTab = items[actualListItem.actualIndex];
            fixedTabIndex = actualTab.tabIndex;
        } else if (actualIndex == 0) {
            actualListItem = tablist.firstChild;
            actualListItem = targetNode;
            actualTab = items[actualListItem.actualIndex];
            fixedTabIndex = -1;
        } else {
            // In list say we push between nodes 2 and 1 (so we're near the right)
            //       [8]
            //        v
            //     [2]  [1]  [0]  <
            // getDropIndex wants to put it before [1]
            // but in reality we're looking at this:
            //
            //            [8]
            //             v
            //   > [0]  [1]  [2]   ==>
            //   > [0]  [1]  [8]  [2] which reversed will look like
            //     [2]  [8]  [1]  [0]
            //   so we want to insert it just before node [2]
            //   so in reverse mode the desired tab-index is the previous sibling's.
            actualListItem = targetNode.previousSibling;
            actualTab = items[actualListItem.actualIndex];
            fixedTabIndex = actualTab.tabIndex;
        }
    } else {
        if (actualIndex == -1) {
            actualListItem = tablist.lastChild;
            actualTab = items[actualListItem.actualIndex];
            fixedTabIndex = -1;
        } else if (actualIndex == 0) {
            actualListItem = targetNode;
            actualTab = items[targetNode.actualIndex];
            fixedTabIndex = actualTab.tabIndex;
        } else {
            actualListItem = targetNode;
            actualTab = items[actualListItem.actualIndex];
            fixedTabIndex = actualTab.tabIndex;
        }
    }
    return [fixedTabIndex, actualListItem, actualTab];
}

function getDropIndex(event) {
    var target = event.target;
    if (["LI", "UL"].indexOf(target.nodeName) == -1) {
        return [null, undefined];
    }
    let offsetY = event.offsetY;
    let liHeight = target.clientHeight;
    if (target.nodeName == "LI") {
        //let preferAfterOffset = (offsetY > Math.ceil(liHeight / 2.0) ? 0 : 1);
        let preferAfter = offsetY > Math.ceil(liHeight / 2.0);
        if (preferAfter) {
            let nextNode = target.nextSibling;
            if (!nextNode) {
                return [-1, target];
            } else {
                return [nextNode.actualIndex, nextNode];
            }
        } else {
            return [target.actualIndex, target];
        }
    } else {
        let actualOffset = offsetY + target.scrollTop;
        let firstChild = target.firstChild;
        if (g_currentItemHeight === null) {
            let nextChild = target.firstChild.nextSibling;
            g_currentItemHeight = nextChild.offsetTop - firstChild.offsetTop;
        }
        let initialMargin = firstChild.offsetTop - target.offsetTop;
        let numBefore = Math.floor((actualOffset - initialMargin) / g_currentItemHeight + 0.3);
        if (numBefore < target.childNodes.length) {
            let node = target.childNodes[numBefore];
            return [node.actualIndex, node];
        }
        // We're at the end
        return [-1, target.lastChild];
    }
}

function onTablistDragOver(event) {
    try {
        event.preventDefault();
        var [actualIndex, newTargetNode] = getDropIndex(event);
        if (newTargetNode == null) {
            return;
        }
        setDragTargetIndicator(newTargetNode, actualIndex);
    } catch(ex) {
        console.log(`tabhunter: error on drag/drop over handler: ${ex}`);
    }
}

function moveTabsToAnotherTab(origTabIds, targetIndex, finalTargetNode, tabInfo) {
    try {
        // We're going to run from the last tab to the first, so reverse if the tabs are reversed
        // Reverse if:
        // not reverse-sort, not targetting end of table
        // reverse-sort, but targetting end of table
        // In all other cases, don't reverse
        //
        // And use `[].concat` to make a copy
        let tabIds = [].concat((!!sortByReverse != (targetIndex == -1)) ? origTabIds.reverse() : origTabIds);
        let targetWindowID = tabInfo.windowID;
        let windowInfo = g_windowInfoArray.find((win) => win.id == targetWindowID);
        let tabIdsToLeftOfTarget = windowInfo.tabs.filter((tabInfo) => tabInfo.index <= targetIndex).map((tabInfo) => tabInfo.id);
        let moveProperties = { windowId: targetWindowID,
                               index: targetIndex };

        var reportErr, moveNextTabFunc;
        reportErr = function(err) {
            console.log("tabhunter: error creating bookmark: " + err);
        };
        
        let selectMovedTargetNode = function(attempt) {
            let firstTabId = sortByReverse ? origTabIds[origTabIds.length - 1] : origTabIds[0];
            let itemIndex = items.findIndex((item) => item.tabID == firstTabId);
            let matchedItemIndex = matchedItems.indexOf(itemIndex);
            if (matchedItemIndex >= 0) {
                tablist.childNodes[matchedItemIndex].classList.add('selected');
            } else if (attempt <= 10) {
                // Sometimes we haven't finished the various promises while updating
                // the node list, so retry
                setTimeout(selectMovedTargetNode, attempt * 10, attempt + 1);
            }
        };
        let populateTabListAndReselect = function() {
            populateTabList();
            setTimeout(selectMovedTargetNode, 10, 1);
        };
        let deferredMoveNextTabFunc = function() {
            setTimeout(moveNextTabFunc, 1);
        };
        moveNextTabFunc = function() {
            if (tabIds.length == 0) {
                // All done
                let s = `Moved ${pluralize(tabIds.length, "tab")} to tab ${tabInfo.title}`;
                setStatusBarMessage(s);
                tablist.querySelectorAll("li.selected").forEach(function(node) {
                    node.classList.remove('selected');
                });
                setTimeout(populateTabListAndReselect, 10);
                return;
            }
            let tabIdToMove = tabIds.pop();
            if (targetIndex != -1 && tabIdsToLeftOfTarget.indexOf(tabIdToMove) >= 0) {
                targetIndex -= 1;
            }
            moveProperties.index = targetIndex;
            browser.tabs.move(tabIdToMove, moveProperties).then(deferredMoveNextTabFunc, reportErr);
            //browser.tabs.move(tabIdToMove, moveProperties).then(moveNextTabFunc, reportErr);

        };
        moveNextTabFunc();
    } catch(ex) {
        console.log("tabhunter: Error moving tabs: " + ex);
    }
}

function onTablistDropHandler(event) {
    try {
        event.preventDefault();
        removeDragTargetIndicator();
        let [targetIndex, finalTargetNode, tabInfo] = getDropIndexWithTabInfo(event);
        if (targetIndex === null || finalTargetNode === undefined) {
            return;
        }
        var tabIds = event.dataTransfer.getData("text").split(/,/).map((x) => parseInt(x, 10));
        moveTabsToAnotherTab(tabIds, targetIndex, finalTargetNode, tabInfo);
    } catch(ex) {
        console.log(`tabhunter: error on drag/drop drop handler: ${ex}`);
    }
    event.preventDefault();
    event.stopPropagation();
}

function removeDragTargetIndicator() {
    if (g_currentDragTarget) {
        g_currentDragTarget.classList.remove(g_currentDragTargetClassName);
        g_currentDragTargetClassName = g_currentDragTarget = null;
    }
}

function setDragTargetIndicator(targetNode, actualIndex) {
    removeDragTargetIndicator();
    g_currentDragTargetClassName = actualIndex == -1 ? 'tabenter-after' : 'tabenter';
    (g_currentDragTarget = targetNode).classList.add(g_currentDragTargetClassName);
}

function updateButtons() {
    var selectedItemLength = getSelectedItemsJQ().length;
    var matchedItemLength = matchedItems.length;
    var otherDisabled = selectedItemLength == 0;
    document.getElementById("go").disabled = selectedItemLength != 1 || matchedItemLength == 0;
    closeTabsButton.disabled = otherDisabled;
    document.getElementById("copyURL").disabled = otherDisabled;
    document.getElementById("copyTitle").disabled = otherDisabled;
    document.getElementById("copyURLTitle").disabled = otherDisabled;
    
    // showAudioButton is always enabled
    
    finishMoveToWindowButton.disabled = otherDisabled;
    discardTabsButton.disabled = otherDisabled;
    activateTabsButton.disabled = !hasDiscardedTabs || otherDisabled;

<% if ENV['TARGET'] == 'firefox' %>
    finishMoveToBookmarkButton.disabled = otherDisabled;
<% end %>
    
    var closeTabsContent = closeTabsButton.textContent;
    var newCloseTabsContent = "";
    var m = matchCloseTabs.exec(closeTabsContent);
    if (m[2] == 's') {
        if (selectedItemLength == 1) {
            newCloseTabsContent = m[1];
        }
    } else if (selectedItemLength > 1) {
        newCloseTabsContent = m[1] + 's';
    }
    if (newCloseTabsContent != "") {
        closeTabsButton.textContent = newCloseTabsContent;
    }
}

function updateURL() {
    var url = document.getElementById("url");
    var selectedItems = getSelectedItemsJQ();
    if (selectedItems.length >= 1) {
        var index = selectedItems[0].actualIndex;
        URL.value = items[index].url;
        return;
    }
    if (matchedItems.length == 1) {
        url.value = items[matchedItems[0]].url;
    } else {
        url.value = "";
    }
}

function updateActivity() {
    var pattern = mainPattern.value;
    var text;
    if (pattern.length == 0 && !g_showAudio && !g_hideDiscardTabs) {
        text = "Hunting through " + items.length + " tabs";
    } else {
        text = "Matched " + matchedItems.length + "/" + items.length + " tabs";
    }
    document.getElementById("activity").innerText = text;
}

// Tabs: save [title, url, window#id, tab#id, tab#index, tab#favIconUrl
function doCloseTabsButton() {
    var selectedItems = getSelectedItemsJQ();
    if (selectedItems.length == 0) {
        return;
    }
    var tabIds = selectedItems.map(function(selectedItem) {
        return items[selectedItem.actualIndex].tabID;
    });
    var removeTabError = function(err) {
        var msg = "Error removing tab: ";
        if (typeof(err) == "string") {
            msg += err;
        } else {
            msg += err.message;
        }
        alert("Error removing tab: " + msg);
    }
    var removeTabOK = function() {
        setTimeout(populateTabList, 10);
    }
    browser.tabs.remove(tabIds).then(removeTabOK, removeTabError);
}

function gatherText(fn) {
    var selectedItems = getSelectedItemsJQ();
    if (selectedItems.length == 0) {
        return;
    }
    var textPieces = selectedItems.map(function(selectedItem) {
        return fn(items[selectedItem.actualIndex]);
    });
    return textPieces.join("\n");
}

function setClipboard(text) {
    try {
        textarea.style.display = "block";
        textarea.textContent = text;
        textarea.select();
        document.execCommand("cut");
    } catch(ex) {
        console.log("tabhunter: Error setting/copying text: " + text);
    }
    textarea.style.display = "none";
}

function doCopyURLButton() {
    var text = gatherText(function(item) { return item.url; });
    setClipboard(text);
}

function doCopyTitleButton() {
    var text = gatherText(function(item) { return item.title; });
    setClipboard(text);
}

function doCopyURLTitleButton() {
    var text = gatherText(function(item) { return item.url + '-' + item.title; });
    setClipboard(text);
}

function showWindowMover() {
    moveToWindowButton.removeEventListener("mouseup", showWindowMover, false);
    moveToWindowButton.addEventListener("mouseup", hideWindowMover, false);
    $("div#moveToWindowArea").removeClass("hide").addClass("show");
    $("span#showMoreActions").removeClass("show").addClass("hide");
    $("span#hideMoreActions").removeClass("hide").addClass("show");
    populateWindowPicker();
<% if ENV['TARGET'] == 'firefox' %>
    if (!g_bookmarkList) {
        // Watch out -- this one is async
        populateBookmarkPicker();
    }
<% end %>
}

function hideWindowMover() {
    moveToWindowButton.removeEventListener("mouseup", hideWindowMover, false);
    moveToWindowButton.addEventListener("mouseup", showWindowMover, false);
    $("div#moveToWindowArea").removeClass("show").addClass("hide");
    $("span#hideMoreActions").removeClass("show").addClass("hide");
    $("span#showMoreActions").removeClass("hide").addClass("show");
}

function populateWindowPicker() {
    try {
    while (selectWindowTargetWidget.lastChild) {
        selectWindowTargetWidget.removeChild(selectWindowTargetWidget.lastChild);
    }
    var i = 0;
    for (var windowInfo of g_windowInfoArray) {
        i += 1;
        let optionElement = document.createElement("option");
        optionElement.value = windowInfo.id;
        optionElement.text = `[${i}] ${getWindowTitle(windowInfo)}`;
        if (i == 1) {
            optionElement.selected = true;
        }
        selectWindowTargetWidget.appendChild(optionElement);
    }
    } catch(ex) { console.log(ex); }
}

function getWindowTitle(windowInfo) {
<% if ENV['TARGET'] == 'firefox' %>
    return windowInfo.title;
<% else %>
    return windowInfo.tabs[0].title
<% end %>
}

function TabChanger(tabIDs, opLabel, op, actualItems) {
    this.index = -1;
    this.tabIDs = tabIDs;
    this.op = op;
    this.opLabel = opLabel;
    this.actualItems = actualItems;
}

TabChanger.prototype = {
    changeTabError: function(error) {
        let s = `Error: ${this.opLabel}: tab ${this.actualItems[this.index].title}: ${error}`;
        setStatusBarMessage(s);
        console.log("tabhunter: " + s);
    },
    next: function() {
        if (this.index >= this.tabIDs.length - 1) {
            setStatusBarMessage(`${this.opLabel} successful`);
            setTimeout(populateTabList, 10);
            return;
        }
        this.index += 1;
        let self = this;
        this.op(this.tabIDs[this.index], this.next.bind(this), this.changeTabError.bind(this));
    }
};    

function discardTheTabs() {
    var selectedItems = getSelectedItemsJQ();
    var selectedActualIndices = selectedItems.map(function(elt) { return elt.actualIndex });
    var actualItems = selectedActualIndices.map((i) => items[i]).filter((item) => !item.discarded && item.tabID != g_activeTab);
    var tabIDs = actualItems.map((item) => item.tabID);
    if (tabIDs.length == 0) {
        let s = "All selected items are already discarded";
        setStatusBarMessage(s);
        console.log("Tabhunter: " + s);
        return;
    }
<% if ENV['TARGET'] == 'firefox' %>
    let discardTabError = function(err) {
        var msg = "Error discarding tab: ";
        if (typeof(err) == "string") {
            msg += err;
        } else {
            msg += err.message;
        }
        setStatusBarMessage(msg)
        console.log("Tabhunter: " + msg);
    }
    let discardTabOK = function() {
        setStatusBarMessage("Discard successful");
        setTimeout(populateTabList, 10);
    }
    browser.tabs.discard(tabIDs).then(discardTabOK, discardTabError);
<% else %>
    new TabChanger(tabIDs, "discard", function(tabID, onResolve, onReject) {
                                         browser.tabs.discard(tabID).
                                         then(onResolve).
                                         catch(onReject);
              }, actualItems).next();
<% end %>
}

function activateTheTabs() {
    var selectedItems = getSelectedItemsJQ();
    var selectedActualIndices = selectedItems.map(function(elt) { return elt.actualIndex });
    var actualItems = selectedActualIndices.map((i) => items[i]).filter((item) => item.discarded);
    var tabIDs = actualItems.map((item) => item.tabID);
    if (tabIDs.length == 0) {
        let s = "All selected items are already activated";
        setStatusBarMessage(s)
        console.log("Tabhunter: " + s);
    } else {
        new TabChanger(tabIDs, "activate", function(tabID, onResolve, onReject) {
              browser.tabs.reload(tabID).
                then(onResolve).
                catch(onReject);
              }, actualItems).next();
    }
}

function doMoveToWindowButton() {
    let reportErr = function(err) {
        console.log("tabhunter: doMoveToWindowButton: " + err);
    };
    let options = selectWindowTargetWidget.selectedOptions;
    if (options.length == 0) {
        alert("No target window to move tabs to");
        return;
    }
    let targetWindowID = parseInt(options.item(0).value, 10);
    let targetIndex = 0;
    g_windowInfoArray.forEach(function(windowInfo) {
        if (windowInfo.id == targetWindowID) {
            targetIndex = windowInfo.tabs.length;
        }
    });
    let selectedItems = getSelectedItemsJQ();
    let itemsToMove = selectedItems.map(function(selectedItem) { return items[selectedItem.actualIndex]; });
    let tabIds = itemsToMove.map(function(item) { return item.tabID; });
    
    browser.tabs.move(tabIds,
                      {windowId: parseInt(targetWindowID, 10),
                       index: targetIndex
                      }
                     ).then(function(tabsList) {
                         populateTabList();
                     }).catch(reportErr);
}

<% if ENV['TARGET'] == 'firefox' %>
function populateBookmarkPicker() {
    try {
        g_bookmarkList = [];
        var i = 0;
        let extractTitlesFromItem = function(bookmarkItem, parentPath) {
            if (bookmarkItem.type != "folder") {
                return;
            }
            var fullPath;
            var nextPath;
            if (bookmarkItem.title) {
                i += 1;
                fullPath = parentPath + bookmarkItem.title;
                nextPath = fullPath + "/";
                let optionElement = document.createElement("option");
                optionElement.value = bookmarkItem.id;
                optionElement.text = `[${i}] ${fullPath}`;
                if (i == 1) {
                    optionElement.selected = true;
                }
                selectBookmarkTargetWidget.appendChild(optionElement);
                g_bookmarkList.push(bookmarkItem.title);
            } else {
                nextPath = parentPath;
            }
                
            if (bookmarkItem.children) {
                for (var child of bookmarkItem.children) {
                    extractTitlesFromItem(child, nextPath);
                }
            }
        };
        let getBookmarkTree = function(items) {
            extractTitlesFromItem(items[0], "");
        }
        let reportErr = function(err) {
            console.log("tabhunter: error getting bookmarks: " + err);
        };
        browser.bookmarks.getTree().then(getBookmarkTree, reportErr);
    } catch(ex) { console.log(ex); }
}

function doMoveToBookmarkButton() {
    try {
    let options = selectBookmarkTargetWidget.selectedOptions;
    if (options.length == 0) {
        alert("No target bookmark to move tabs to");
        return;
    }
    let targetBookmarkID = options.item(0).value;
    let selectedItems = getSelectedItemsJQ();
    let itemsToMove = selectedItems.map(function(selectedItem) { return items[selectedItem.actualIndex]; });
    let urls = itemsToMove.map(function(item) { return item.url; });
        let index = -1;
        var reportErr, moveNextURL;
    reportErr = function(err) {
        console.log("tabhunter: error creating bookmark: " + err);
    };
    moveNextURL = function(newBookmark) {
        if (index >= urls.length - 1) {
            let s = `Moved ${pluralize(urls.length, "tab")} to bookmark ${options.item(0).text}`;
            setStatusBarMessage(s);
            return;
        }
        index += 1;
        browser.bookmarks.create({
            parentId: targetBookmarkID,
            url: urls[index]
        }).then(moveNextURL, reportErr);
    };
    moveNextURL(null);
    } catch(ex) { console.log(ex); }
}
<% end %>

function doHandleAudioCheckbox() {
    g_showAudio = showAudioButton.checked;
    browser.storage.local.set({"showAudio": g_showAudio});
    onPatternChanged(null, false);
}

function doHideDiscardedTabsCheckbox() {
    g_hideDiscardTabs = hideDiscardedTabsButton.checked;
    browser.storage.local.set({"hideDiscardTabs": g_hideDiscardTabs});
    onPatternChanged(null, false);
}

function doGoButton() {
    var selItems = getSelectedItemsJQ();
    if (selItems.length == 1 || matchedItems.length == 1) {
        doVisitSelectedURL();
    }
}

function getModifierMask(event) {
    return (0 |
            (event.shiftKey ? SHIFT_KEY : 0 ) |
            (event.ctrlKey ? CTRL_KEY : 0 ) |
            (event.altKey ? ALT_KEY : 0 ) |
            (event.metaKey ?  CTRL_KEY: 0 ) |
            (event.commandKey ? CTRL_KEY : 0 ));
}

return {
    init: function () {
        return init();
    },
    reloadPrefsAndMatches: getCloseOnGoPref,
    __BOSCO__ : null
};

});

var thMain = null;
$(document).ready(function() {
  thMain = thMainFunc();
  thMain.init();
});

