// tabhunter.js -- See LICENSE.txt for copyright and license details. 
// -*- Mode: javascript; indent-tab-mode: nil; js-indent-level: 4 -*-

var thMainFunc = (function() {  //    })

var items = [];
var selectedIndex;    // visible
var lastClickedIndex; // visible
var matchedItems;
var tablist;
var mainPattern;
const listBuilderChunkSize = 100;
var textarea;
var showElapsedTimes = false; // Need a way to enable this.
var t1, t2;
var closeTabsButton;
var matchCloseTabs;
var showAudioButton;
var hideDiscardedTabsButton;
var moveToWindowButton;
var showSearchTextAreaButton;
var selectAllButton;
var searchTextArea;
var searchTextField;
var searchTextSearchButton;
var discardTabsButton;
var activateTabsButton;
var reloadTabsButton;
var hasDiscardedTabs;
var selectWindowTargetWidget;
var finishMoveToWindowButton;
<% if ENV['TARGET'] == 'firefox' %>
var selectBookmarkTargetWidget;
var finishMoveToBookmarkButton;
var g_bookmarkList = null;
<% end %>
var g_showAudio;
var g_hideDiscardTabs;
var g_activeTab;
var g_windowInfoArray;
<% if ENV['TARGET'] == 'chrome' %>
var g_itemSupportsLastAccessed = null;
<% end %>
var closeOnGo = true;
var sortBy = null;
var sortByReverse = false;
var useDarkTheme = false;
var controlVisitN = false;
var g_currentDragTarget = null, g_currentDragTargetClassName = null;
var g_currentItemHeight = null;
const DEFAULT_BASE_FONT_SIZE = 12;

// List builder to coroutinize the list-populator
var listBuilder = null;

// Search stuff
var tabsWithText; // Keep track of which tabs have scripts in them
var originalMatchedItems; // Restore the matched tabs if search went bad
var sessionMatchedItems; // Keep sorting on these in a session
var tabIDsForSearching; // Array of [tabID, item index]

var searchTextProgressBar, searchTextPauseButton, searchTextCancelButton;
var searchTextPauseNow, searchTextCancelNow, currentSearcher;

function init() {
    var list = document.getElementById("list");
    mainPattern = document.getElementById("pattern");
    searchTextField = document.getElementById("searchText");
    textarea = document.getElementById("textarea");
    g_activeTab = -1;

    tablist = list;

    mainPattern.addEventListener("input", onPatternChanged, false);
    searchTextField.addEventListener("input", onSearchTextFieldChanged, false);
    searchTextField.addEventListener("keydown", onSearchTextFieldKeyup, true);
    document.addEventListener("keydown", processArrowKey, false);
    document.getElementById("go").addEventListener("mouseup", doGoButton, false);
    closeTabsButton = document.getElementById("closeTabs");
    closeTabsButton.addEventListener("mouseup", doCloseTabsButton, false);
    document.getElementById("copyURL").addEventListener("mouseup", doCopyURLButton, false);
    document.getElementById("copyTitle").addEventListener("mouseup", doCopyTitleButton, false);
    document.getElementById("copyURLTitle").addEventListener("mouseup", doCopyURLTitleButton, false);
    selectAllButton = document.getElementById("selectAllButton");
    selectAllButton.addEventListener("mouseup", doSelectAll, false);
    
    showAudioButton = document.getElementById("showAudio");
    showAudioButton.addEventListener("click", doHandleAudioCheckbox, false);
    g_showAudio = showAudioButton.checked;
    
    hideDiscardedTabsButton = document.getElementById("hideDiscardedTabs");
    hideDiscardedTabsButton.addEventListener("click", doHideDiscardedTabsCheckbox, false);
    g_hideDiscardTabs = hideDiscardedTabsButton.checked;
    hasDiscardedTabs = false;
    
    moveToWindowButton = document.getElementById("moveToWindow");
    moveToWindowButton.addEventListener("mouseup", showWindowMover, false);
    searchTextArea = document.getElementById("searchTextArea");
    showSearchTextAreaButton = document.getElementById("showSearchTextPanel");
    showSearchTextAreaButton.addEventListener("mouseup", showSearchTextArea, false);
    searchTextSearchButton = document.getElementById("searchTextSearchButton");
    searchTextSearchButton.addEventListener("mouseup", doSearchForTheText, false);

    discardTabsButton = document.getElementById("discardSelectedTabs");
    discardTabsButton.addEventListener("mouseup", discardTheTabs, false);
    activateTabsButton = document.getElementById("activateSelectedTabs");
    activateTabsButton.addEventListener("mouseup", activateTheTabs, false);
    reloadTabsButton = document.getElementById("reloadTabsButton");
    reloadTabsButton.addEventListener("mouseup", doReloadTabs, false);

    selectWindowTargetWidget = document.getElementById("windowList");
    finishMoveToWindowButton = document.getElementById("doMoveToWindow");
    finishMoveToWindowButton.addEventListener("mouseup", doMoveToWindowButton, false);
<% if ENV['TARGET'] == 'firefox' %>
    selectBookmarkTargetWidget = document.getElementById("bookmarkList");
    finishMoveToBookmarkButton = document.getElementById("doMoveToBookmark");
    finishMoveToBookmarkButton.addEventListener("mouseup", doMoveToBookmarkButton, false);
<% end %>

    searchTextProgressBar = document.getElementById("searchTextProgressBar");
    searchTextPauseButton = document.getElementById("searchTextPauseButton");
    searchTextPauseButton.addEventListener("mouseup", doSearchTextPause, false);
    searchTextPauseButton.disabled = true;
    searchTextCancelButton = document.getElementById("searchTextCancelButton");
    searchTextCancelButton.disabled = true;
    searchTextCancelButton.addEventListener("mouseup", doSearchTextCancel, false);
    
    matchCloseTabs = /^(.*?)(s?)$/;

    $("button").mouseover(doMouseOver);
    $("button").mouseout(doMouseOut);
    $("button").mousedown(doMouseDown);
    $("button").mouseup(doMouseUp);

    // Search stuff
    tabsWithText = new Set(); // set tabID when it's ready
    let observerOptions = {
      attributes: true
    };
    let observer = new MutationObserver(onSearchTextAreaChanged);
    observer.observe(searchTextArea, observerOptions);

    var gotPatternOK = function(item) {
        if ('pattern' in item) {
            mainPattern.value = item.pattern;
        } else {
            mainPattern.value = '';
        }
        selectPattern();
        restoreAudioSetting();
    };
    var gotPatternErr = function(err) {
        restoreAudioSetting();
    };
    browser.storage.local.get("pattern").then(gotPatternOK, gotPatternErr);
}

function selectPattern() {
    mainPattern.focus();
    if (mainPattern.value) {
        mainPattern.select();
    }
}

function restoreAudioSetting() {
    var gotSettingOK = function(item) {
        if ('showAudio' in item) {
            g_showAudio = item.showAudio;
            showAudioButton.checked = g_showAudio;
        }
        if ('hideDiscardTabs' in item) {
            g_hideDiscardTabs = item.hideDiscardTabs;
            hideDiscardedTabsButton.checked = g_hideDiscardTabs;
        }
<% if ENV['TARGET'] == 'firefox' %>
        getCurrentTheme();
<% else %>
        restoreHideAudioSetting();
<% end %>
    };
    var gotSettingErr = function(err) {
<% if ENV['TARGET'] == 'firefox' %>
        getCurrentTheme();
<% else %>
        restoreHideAudioSetting();
<% end %>
    };
    browser.storage.local.get("showAudio").then(gotSettingOK, gotSettingErr);
}

<% if ENV['TARGET'] == 'firefox' %>
function getCurrentTheme() {
    var gotSettingOK = function(theme) {
        // Assume the worst
        useDarkTheme = false;
        if (theme.colors) {
            //console.table(theme.colors);
            if ('popup' in theme.colors) {
                let popupColor = theme.colors['popup'];
                try {
                    let rgbColor = new RGBColor(popupColor);
                    if (rgbColor.ok) {
                        let numDarkColors = 0;
                        let numBrightColors = 0;
                        ['r', 'g', 'b'].forEach(function(color) {
                                if (rgbColor[color] < 255 / 3) {
                                    numDarkColors += 1;
                                } else if (rgbColor[color] > (255 * 2 / 3)) { 
                                    numBrightColors += 1;
                                }
                            });
                        if (numDarkColors >= 2 && numBrightColors == 0) {
                            useDarkTheme = true;
                        }
                    }
                } catch(e) {
                    console.log("tabhunter: error in color analyzer: " + e);
                }
            }
        } else {
            //console.log("We're probably using the default theme");
        }
        if (useDarkTheme) {
            ['body', 'input', 'ul#list', 'button', 'select'].forEach(function(selector) {
                    $(selector).addClass('dark');
                });
        }
        restoreHideAudioSetting();
    };
    var gotSettingErr = function(err) {
        console.log("tabhunter: error getting theme: " + err);
        restoreHideAudioSetting();
    };
    browser.theme.getCurrent().then(gotSettingOK, gotSettingErr);
}
<% end %>
    
function restoreHideAudioSetting() {
    var gotSettingOK = function(item) {
        if ('hideDiscardTabs' in item) {
            g_hideDiscardTabs = item.hideDiscardTabs;
            hideDiscardedTabsButton.checked = g_hideDiscardTabs;
        }
        getCloseOnGoPref();
    };
    var gotSettingErr = function(err) {
        populateTabList();
    };
    browser.storage.local.get("hideDiscardTabs").then(gotSettingOK, gotSettingErr);
}

function depx(pref) {
    let p = /^(\d+).*/;
    let m = p.exec(pref);
    if (m) {
        return parseInt(m[1], 10);
    }
    return parseInt(pref, 10);
}

function px(size) {
    return `${size}px`;
}

function getCloseOnGoPref() {
    //TODO: fold the two closeOnGo settings and look for other
    // settings that are in both prefs and outside it.
    let gotPrefOK = function(item) {
        if ('searchTextField' in item) {
            searchTextField.value = item['searchTextField'];
            enableSearchTextButton(searchTextField);
        }
        let prefs = item["prefs"];
        if (prefs && 'sortBy' in prefs) {
            sortBy = comparisonFunctions[prefs['sortBy']];
        }
        if (!sortBy) {
            sortBy = comparisonFunctions['Title'];
        }
        if (prefs && 'sortByReverse' in prefs) {
            sortByReverse = !!prefs['sortByReverse'];
        }
        if (prefs && 'controlVisitN' in prefs) {
            controlVisitN = !!prefs['controlVisitN'];
            if (controlVisitN) {
                document.addEventListener("keyup", processKey, false);
            }
        }
        if (prefs && 'fontSize' in prefs) {
            let baseFontSize = depx(prefs['fontSize']) || DEFAULT_BASE_FONT_SIZE;
            list.style.fontSize = px(baseFontSize);
            $('body').css('font-size', px(baseFontSize + 1));
            $('label.text').css('font-size', px(baseFontSize));
            $('label.checkbox').css('font-size', px(baseFontSize - 1));
            $('div#buttons.button').css('font-size', px(baseFontSize - 1));
            $('ul#list').css('font-size', px(baseFontSize));
            $('span#activity').css('font-size', px(baseFontSize + 1));
        }
        if (prefs && "closeOnGo" in prefs) {
            closeOnGo = prefs["closeOnGo"];
        } else {
            closeOnGo = null;
        }
        if (closeOnGo !== true && closeOnGo !== false) {
            closeOnGo = true;
            let continueFuncOK = function() {
                populateTabList();
            };
            let continueFuncErr = function(err) {
                populateTabList();
            };
            
            browser.storage.local.set({"closeOnGo": closeOnGo}).then(continueFuncOK, continueFuncErr);
        } else {
            populateTabList();
        }
    };
    let gotPrefErr = function(err) {
        console.log(`tabhunter: getCloseOnGoPref.gotPrefErr: err: ${err}`);
        populateTabList();
    };
    browser.storage.local.get().then(gotPrefOK, gotPrefErr);
}

function WindowIndexThing() {
    this.currentIndex = 0;
    this.indicesByID = {};
}
WindowIndexThing.prototype = {
    intern: function(windowID) {
        if (windowID in this.indicesByID) {
            return this.indicesByID[windowID];
        }
        this.currentIndex += 1;
        this.indicesByID[windowID] = this.currentIndex;
        return this.currentIndex;
    },
    index: function(windowID) {
        return this.indicesByID[windowID];
    },
    __EOT__: null
}
var windowCounter = new WindowIndexThing();

// Tabs: save [title, url, window#id, tab#id, tab#index, tab#favIconUrl, tab#audible] 
function makeTabItem(id, tab) {
    windowCounter.intern(id);
    return {
      title: tab.title,
      url: tab.url,
      windowID: id,
      tabID: tab.id,
      tabIndex: tab.index,
      favIconUrl: tab.favIconUrl,
      lastAccessed: tab.lastAccessed,
      discarded: tab.discarded,
      audible: tab.audible
    };
}

function isForbiddenFavIconUrl(url) {
    return ['chrome://mozapps/skin/extensions/extensionGeneric-16.svg',
           'chrome://mozapps/skin/extensions/extensionGeneric-16.png'].indexOf(url) >= 0;
}

function subCompareByKey(tab1, tab2, key) {
    let s1 = tab1[key].toLowerCase();
    let s2 = tab2[key].toLowerCase();
    if (s1 < s2) return -1;
    if (s1 > s2) return 1;
    return 0;
}

function compareByTitle(tab1, tab2) {
    let res = subCompareByKey(tab1, tab2, 'title');
    if (res != 0) return res;
    res = subCompareByKey(tab1, tab2, 'url');
    if (res != 0) return res;
    return compareByWindowTab(tab1, tab2);
}

function compareByURL(tab1, tab2) {
    let res = subCompareByKey(tab1, tab2, 'url');
    if (res != 0) return res;
    res = subCompareByKey(tab1, tab2, 'title');
    if (res != 0) return res;
    return compareByWindowTab(tab1, tab2);
}

function compareByNeglect(tab1, tab2) {
    let res = tab1.lastAccessed - tab2.lastAccessed;
    if (res != 0) return res;
    return compareByTitle(tab1, tab2);
}

function compareByWindowTab(tab1, tab2) {
    let windowID1 = tab1.windowID;
    let windowID2 = tab2.windowID;
    if (windowID1 < windowID2) return -1;
    if (windowID1 > windowID2) return 1;
    let tabIndex1 = tab1.tabIndex;
    let tabIndex2 = tab2.tabIndex;
    return tabIndex1 - tabIndex2;
}

const comparisonFunctions = {'Title': compareByTitle,
                             'URL': compareByURL,
                             'Neglect': compareByNeglect,
                             'Position': compareByWindowTab};

function sortByWithReverseCheck(tab1, tab2) {
    return (sortByReverse ? -1 : 1) * sortBy(tab1, tab2);
}

function getReadableAge(ts) {
    let age = (new Date().valueOf() - ts) / 1000;  // sec
    if (age < 60) {
        return `${Math.round(age)} sec`;
    }
    age /= 60; // mins.
    if (age < 60) {
        return `${Math.round(age)} min`;
    }
    age /= 60; // hours.
    if (age < 24) {
        return `${Math.round(age)} hr`;
    }
    age /= 24; // days.
    if (age <= 60) {
        return pluralize(Math.round(age), 'day');
    }
    if (age <= 366) {
        return `${Math.round(age / 7)} weeks`;
    }
    let daysPerMonth = 365.25 / 12;
    let months = Math.round(age / daysPerMonth);
    if (months < 12) {
        return `${pluralize(months, 'mo')}`;
    }
    let years = Math.floor(months / 12);
    months = months % 12;
    if (months > 0) {
        return `${pluralize(years, 'yr')} ${pluralize(months, 'mo')}`;
    }
    return `${pluralize(years, 'yr')}`;
}

function pluralize(amt, term) {
    var suffix = (amt == 1) ? "" : "s";
    return `${amt} ${term}${suffix}`;
}

function populateTabList() {
    selectedIndex = 0;
    lastClickedIndex = -1;
    g_currentItemHeight = null;
    const getAllProperties = {populate: true, windowTypes: ['normal']}
    const endTime = function(cmd) {
        t2 = (new Date()).valueOf();
        //console.log("Elapsed time to " + cmd + ": " + ((t2 - t1)/1000) + " msec");
    }
    const errGetAllWindows = function(err) {
        if (showElapsedTimes) {
            endTime("getting windows");
        }
        console.log(`tabhunter: errGetAllWindows: err: ${err}`);
    }
    
    const doGetAllWindows = function (windowInfoArray) {
        g_windowInfoArray = windowInfoArray;
        if (showElapsedTimes) {
            endTime("getting " + (windowInfoArray.length) + " windows");
            t1 = (new Date()).valueOf();
        }
        items.splice(0); // clear
        //TODO: Use a heap array to make building a sorted list one item at a time
        // an n . lg(n) operation
        for (var windowInfo of windowInfoArray) {
            var id = windowInfo.id;
            var tabs = windowInfo.tabs;
            for (var tab of tabs) {
                if (tab.active && windowInfo.focused) {
                    g_activeTab = tab.id;
                }
                // Tabs: save [title, url, window#id, tab#id, tab#index, tab#favIconUrl
                items.push(makeTabItem(id, tab));
            }
        }
        if (showElapsedTimes) {
            endTime("getting tabs");
            t1 = (new Date()).valueOf();
        }
        items.sort(sortByWithReverseCheck);
        
        if (showElapsedTimes) {
            endTime("sorting tabs");
            t1 = (new Date()).valueOf();
        }
        onPatternChanged(null, true);
        
        if (showElapsedTimes) {
            endTime("setting matched tabs");
        }
        // Need to do this in a setTimeout of 100 msec for reasons unknown
        setTimeout(function() {
            try {
                selectPattern();
            } catch(e) {
                console.log("tabhunter: * mainPattern.focus(): " + e);
            }
        }, 100);
    };
    t1 = (new Date()).valueOf();
    // Load all the tabs each time we show the popup.
    //TODO: Maintain the tab list in the background processor, so we can show
    // them faster here.

    browser.windows.getAll(getAllProperties).then(doGetAllWindows, errGetAllWindows);
}

function doMouseOver(eventData) {
    if (!eventData.currentTarget.disabled) {
        $(this).addClass("highlighted");
    }
}

function doMouseOut(eventData) {
    $(this).removeClass("highlighted");
    $(this).removeClass("pressed");
}

function doMouseDown(eventData) {
    if (!eventData.currentTarget.disabled) {
        $(this).addClass("pressed");
    }
}

function doMouseUp(eventData) {
    $(this).removeClass("pressed");
}

function doVisitSelectedURL() {
    if (selectedIndex < 0 || selectedIndex >= matchedItems.length) {
        return;
    }
    var target = items[matchedItems[selectedIndex]];
    // target: tab.title, tab.url, window.id, tab.id, tab.index
    var windowId = target.windowID;
    var tabId = target.tabID;

    const getCurrentErr = function(err) {
        console.log("tabhunter: Error getting current window: " + err);
    };
    const getCurrentCont = function(windowInfo) {
        if (windowInfo.id != windowId) {
            const showWindowErr = function(err) {
                console.log("tabhunter: Error showing current window: " + err);
            };
            const showWindowCont = function(windowInfo) {
                if (closeOnGo) {
                    close();
                }
            }
            const updateInfo = { focused: true, drawAttention: true };
            if (windowInfo.state == "minimized") {
                updateInfo.state = "normal";
            }
            browser.windows.update(target.windowID, updateInfo).then(showWindowCont, showWindowErr);
        } else {
            if (closeOnGo) {
                close();
            }
        }
    };

    const showTabErr = function(err) {
        console.log("tabhunter: Error showing tab id " + tabId + ": " + err);
    };
    const showTabCont = function(tab) {
        browser.windows.getCurrent().then(getCurrentCont, getCurrentErr);
    };
    const showTab = function() {
        var updateProperties = {active: true} ; // firefox doesn't do:, selected: true}
        browser.tabs.update(tabId, updateProperties).then(showTabCont, showTabErr);
    };
    showTab();
}

function processArrowKey(event) {
    try {
        processArrowKey_aux(event);
    } catch(e) {
        console.log("tabhunter: *** processArrowKey: awp: " + e);
    }
}

const SHIFT_KEY = 1;
const CTRL_KEY = 2;
const ALT_KEY = 4;

function processKey(event) {
    try {
        var mask = getModifierMask(event);
        var keyName = event.key;
        if (keyName == "Control") {
            return;
        }
        if ((mask & (SHIFT_KEY|CTRL_KEY|ALT_KEY)) == CTRL_KEY) {
            if (keyName >= '1' && keyName <= '9') {
                let keyValue = parseInt(keyName, 10);
                if (keyValue <= matchedItems.length) {
                    selectedIndex = keyValue - 1;
                    doVisitSelectedURL();
                    event.stopPropagation();
                    event.preventDefault();
                    return;
                }
            } else {
                console.log("**** keyName: " + keyName);
            }
        }
    } catch(e) {
        console.log("tabhunter: *** processKey: awp: " + e);
    }
}

function processArrowKey_aux(event) {
    var mask = getModifierMask(event);

    var selectedItems = getSelectedItemsJQ();
    var keyName = event.key;
    if (keyName == "Enter") {
        if (mask != 0) {
            console.log("tabhunter: Enter can't be modified with shift, etc.");
        } else {
            if (selectedItems.length > 1) {
                // Keep existing behavior
                selectedIndex = selectedItems[0].actualIndex;
            } 
            doVisitSelectedURL();
        }
        event.stopPropagation();
        event.preventDefault();
        return;
    } else if (keyName == "A" && (mask & (SHIFT_KEY|CTRL_KEY|ALT_KEY)) == (SHIFT_KEY|CTRL_KEY)) {
        doSelectAll();
        event.stopPropagation();
        event.preventDefault();
        return;
    }
    var newSelectedIndex;
    if (keyName == "ArrowUp") {
        if (selectedIndex <= 0) {
            return;
        }
        newSelectedIndex = selectedIndex - 1;
    } else if (keyName == "ArrowDown") {
        if (selectedIndex >= matchedItems.length - 1) {
            return;
        }
        newSelectedIndex = selectedIndex + 1;
    } else {
        return;
    }
    var li = tablist.childNodes[newSelectedIndex];
    if ((mask & SHIFT_KEY) != SHIFT_KEY) {
        $("ul li").removeClass('selected');
    }
    if (li.addClass) {
        li.classList.addClass("selected");
    } else {
        li.setAttribute("class", "selected");
    }
    selectedIndex = newSelectedIndex;
    var url = document.getElementById("url");
    url.value = items[matchedItems[selectedIndex]].url;
    li.scrollIntoView({ block: 'nearest', inline: 'nearest' });
}

function onListItemClick(event) {
    var i = event.target.visibleIndex;
    var mask = getModifierMask(event);
    
    if (mask == SHIFT_KEY && lastClickedIndex > -1) {
        selectRange(lastClickedIndex, i);
    } else if (mask == CTRL_KEY) {
        $(this).toggleClass('selected');
    } else {
        $("ul li").removeClass('selected');
        $(this).addClass('selected');
    }
    selectedIndex = i;
    lastClickedIndex = (mask & (SHIFT_KEY|CTRL_KEY)) == 0 ? i : -1;
    document.getElementById("url").value = items[matchedItems[i]].url;
    updateButtons();
}

function selectRange(lastClickedIndex, currentIndex) {
    if (lastClickedIndex > currentIndex) {
        [lastClickedIndex, currentIndex] = [currentIndex, lastClickedIndex];
    }
    for (var i = lastClickedIndex; i <= currentIndex; i++) {
        tablist.childNodes[i].setAttribute("class", "selected");
    }
}

function onListItemDoubleClick(event) {
    doVisitSelectedURL();
    event.preventDefault();
}

function allowAll() {
    return true;
}

function onPatternChanged(event, calledFromInit) {
    if (listBuilder) {
        listBuilder.stopWorking();
    }
    var pattern = mainPattern.value;
    browser.storage.local.set({"pattern": pattern});
    buildMatchedItemsArray(pattern);
    if (calledFromInit && g_showAudio && matchedItems.length == 0 && pattern == "") {
        // This can only be called once this way
        showAudioButton.checked = g_showAudio = false;
        // setTimeout to allow the button to get checked before the code continues.
        setTimeout(onPatternChanged, 10, null, false);
        return;
    }
    makeListFromMatchedItems();
}

function buildMatchedItemsArray(pattern) {
    //  Adhoc timing shows testing takes negligible time. Like 100 usec/item. So don't coroutinize this one.
    matchedItems = [];
    var ptn;
    var fn, winFnParts = [];
    if (pattern.length == 0) {
        fn = allowAll;
    } else {
        // If the pattern contains a window-selector, handle it
        let p = /^(.*)\{w:?(\d+)(?::([-\d]+))?\}(.*)$/;
        let m = p.exec(pattern);
        if (m) {
            let winNum = parseInt(m[2], 10);
            winFnParts.push(function(item) {
                return windowCounter.index(item.windowID) == winNum;
            });
            if (m[3] !== undefined) {
                let [startTabNum, endTabNum] = m[2].split('-', 2);
                if (endTabNum == undefined) {
                    endTabNum = 1000000;
                } else if (endTabNum.includes('-')) {
                    console.log('Tabhunter: at most one dash allowed in a tab list');
                    //TODO: Write out an error message
                    winFnParts.push(function(item) {
                        return false;
                    });
                }
                if (startTabNum != "") {
                    startTabNum = parseInt(startTabNum, 10) - 1;
                    winFnParts.push(function(item) {
                        return item.tabIndex >= startTabNum
                    });
                }
                if (endTabNum != "") {
                    endTabNum = parseInt(endTabNum, 10) - 1;
                    winFnParts.push(function(item) {
                        return item.tabIndex <= endTabNum
                    });
                }
            }
            pattern = m[1] + m[4];
        }

        // If the pattern contains a negate meta-directive, then negate the
        // filtering behaviour
        let negate = false;
        p = /^(.*)\{!:\}(.*)$/;
        m = p.exec(pattern);
        if (m) {
            pattern = m[1] + m[2]
            negate = true;
        }

        try {
            if (/[A-Z]/.test(pattern) && /[a-z]/.test(pattern)) {
                // If they specify both cases, don't ignore case.
                ptn = new RegExp(pattern);
            } else {
                ptn = new RegExp(pattern, "i");
            }
            fn = function matchPtn(item) {
                const match = ptn.test(item.title) || ptn.test(item.url);
                if (negate) {
                    return !match
                }
                return match
            }
        } catch(ex) {
            console.log("tabhunter: not a valid javascript pattern: " + ex);
            // just do a case-insensitive substring search
            // just do a case-insensitive substring search
            ptn = pattern.toLowerCase();
            fn = function matchText(item) {
              return (
                item.title.toLowerCase().includes(ptn) || item.url.toLowerCase().includes(ptn)
              );
            };
        }
    }
    for (var i = 0; i < items.length; i++) {
        let item = items[i];
        if ((!winFnParts.every((f) => f(item)))
            || (g_showAudio && !item.audible)) {
            continue;
        }
        if (item.discarded) {
            hasDiscardedTabs = true;
            if (g_hideDiscardTabs) {
                continue;
            }
        }
        if (fn(item)) {
            matchedItems.push(i);
        }
    }
}

function setStatusBarMessage(msg) {
    $("div#statusbar").removeClass("hide").addClass("show");
    $("p#statusbar-p").text(msg);
    setTimeout(function() {
        $("div#statusbar").removeClass("show").addClass("hide");
        $("p#statusbar-p").text("");
    }, 30* 1000);
}

function makeListFromMatchedItems(doneFunc) {
    listBuilder = new ListBuilder(doneFunc);
    listBuilder.makeListFromMatchedItems();
}

function ListBuilder(doneFunc) {
    this._stopWorking = false;
    this.index = 0;
    this.numItems = matchedItems.length;
    this.doneFunc = doneFunc;
    
    var selectedItems = getSelectedItemsJQ();
    this.selectedActualIndices = selectedItems.map(function(elt) { return elt.actualIndex });
    this.lastClickedActualIndex = matchedItems[lastClickedIndex];
    this.selectedActualIndex = matchedItems[selectedIndex];
    $("#list").empty();
    $("ul li").off("dblclick", onListItemDoubleClick);
    $("ul li").off("click", onListItemClick);
    selectedIndex = 0;
    lastClickedIndex = -1;
<% if ENV['TARGET'] == 'chrome' %>
    if (sortBy == compareByNeglect && g_itemSupportsLastAccessed === null && items.length > 0) {
        g_itemSupportsLastAccessed = (items[0].lastAccessed !== undefined);
    }
<% end %>
}

ListBuilder.prototype = {
  makeListFromMatchedItems: function() {
        if (this._stopWorking) {
            return;
        }
        let i = this.index;
        let lim = i + listBuilderChunkSize;
        let needTimeout;
        if (lim >= this.numItems) {
            lim = this.numItems;
            needTimeout = false;
        } else {
            needTimeout = true;
        }
        
        for (i; i < lim; i++) {
            var idx = matchedItems[i];
            var item = items[idx];
            var el = document.createElement("li");
            if (sortBy == compareByWindowTab) {
                // Add 1 because not all tabhunter users are proggers
                el.textContent = `[${windowCounter.index(item.windowID)}:${item.tabIndex + 1}] `;
            } else {
                el.textContent = '';
            }
            el.textContent += item.title + " - " + item.url;
            if (sortBy == compareByNeglect
                <% if ENV['TARGET'] == 'chrome' %>
                && g_itemSupportsLastAccessed
                <% end %>
                ) {
                el.textContent += ` [${getReadableAge(item.lastAccessed)}]`;
            }
            el.visibleIndex = i;
            el.actualIndex = idx;
            if (item.favIconUrl && !isForbiddenFavIconUrl(item.favIconUrl)) {
                el.style.backgroundImage = "url(" + item.favIconUrl + ")";
            }
            if (this.selectedActualIndices.indexOf(idx) >= 0) {
                $(el).addClass("selected");
                if (idx == this.selectedActualIndex) {
                    selectedIndex = i;
                }
            }
            if (lastClickedIndex > -1 && idx == this.lastClickedActualIndex) {
                lastClickedIndex = i;
            }
            if (i > 0) {
                let prevIdx = matchedItems[i - 1];
                let prevItem = items[prevIdx];
                // Tabs might have url='about:blank' if they're neglected and
                // haven't been reloaded after a restart...
                if (prevItem.url == item.url && prevItem.title == item.title) {
                    $(el).addClass("duplicate");
                    el.textContent = el.textContent + " [DUP]";
                }
            }
            if (item.discarded) {
                $(el).addClass("discarded");
            }
            if (sortBy == compareByWindowTab) {
                $(el).attr("draggable", true);
            }
            tablist.appendChild(el);
        }
        if (needTimeout) {
            this.index = lim;
            setTimeout(this.makeListFromMatchedItems.bind(this), 0);
        } else {
            if (sortBy == compareByWindowTab) {
                $(tablist).attr("draggable", true);
                tablist.addEventListener("dragstart", onTablistDragStartHandler, true);
                tablist.addEventListener("dragover", onTablistDragOver, true);
                tablist.addEventListener("drop", onTablistDropHandler, false);
            }
            $("ul li:eq(" + selectedIndex + ")").select();
            $("ul li").on("click", onListItemClick);
            $("ul li").on("dblclick", onListItemDoubleClick);
            updateActivity();
            updateURL();
            updateButtons();
            if (this.doneFunc) {
                this.doneFunc();
            }
        }
    },

  stopWorking: function() {
        this._stopWorking = true;
    },
  
  __EOF__: null
}

function getSelectedItemsJQ() {
    return $("ul#list li.selected").toArray();
}

function onTablistDragStartHandler(event) {
    try {
        if (sortByReverse) {
            let msg = document.getElementById("activity").innerText;
            let extra = ". Drag/drop disabled when viewing tabs in reverse-order.-- It's just too weird";
            if (msg.indexOf(extra) == -1) {
                msg += extra;
            }
            document.getElementById("activity").innerText = msg;
            setTimeout(updateActivity, 15 * 1000);
            event.stopPropagation();
            event.preventDefault();
            return false;
        }
        var selectedItems = getSelectedItemsJQ();
        if (selectedItems.length == 0) {
            return;
        }
        //event.preventDefault();
        var urls = [], indices = [];
        selectedItems.forEach(function(selectedItem) {
            let index = selectedItem.actualIndex;
            indices.push(index);
            urls.push(items[index].url);
        });
        // Add the drag data
        event.dataTransfer.setData("text/plain", indices.join(","));
        event.dataTransfer.setData("text/uri-list", urls.join("\n"));
    } catch(ex) {
        console.log(`tabhunter: error on drag/drop start handler: ${ex}`);
    }
}

function getDropIndexWithTabInfo(event, actualIndices) {
    // return [tabIndex, tabItem]
    let [actualIndex, targetNode] = getDropIndex(event, actualIndices);
    if (actualIndex === null || targetNode === undefined) {
        return [actualIndex, undefined];
    }
    let fixedTabIndex = 0, actualTab;
    if (actualIndex == -1) {
        actualTab = items[tablist.lastChild.actualIndex];
        fixedTabIndex = -1;
    } else if (actualIndex == 0) {
        actualTab = items[targetNode.actualIndex];
        fixedTabIndex = actualTab.tabIndex;
    } else {
        actualTab = items[targetNode.actualIndex];
        fixedTabIndex = actualTab.tabIndex;
    }
    return [fixedTabIndex, actualTab];
}


// returns [tabIndex, listItem]
// If we're pointing into a block of selected items, find the first one in the list
// Always return [index, node]
function getDropIndexAtStartOfRun(listItem) {
    let isSelected = function(elt) {
        return elt.classList.contains('selected');
    };
    if (isSelected(listItem)) {
        while (listItem.previousSibling && isSelected(listItem.previousSibling)) {
            listItem = listItem.previousSibling;
        }
    }
    return [listItem.actualIndex, listItem];
}

// returns [tabIndex, listItem]
function getDropIndex(event, actualIndices) {
    var target = event.target;
    if (["LI", "UL"].indexOf(target.nodeName) == -1) {
        return [null, undefined];
    }
    let offsetY = event.offsetY;
    let liHeight = target.clientHeight;
    if (target.nodeName == "LI") {
        let preferAfter = offsetY > Math.ceil(liHeight / 2.0);
        if (preferAfter) {
            let nextNode = target.nextSibling;
            if (!nextNode) {
                return [-1, target];
            } else {
                return getDropIndexAtStartOfRun(nextNode);
            }
        } else {
            return getDropIndexAtStartOfRun(target);
        }
    } else {
        let actualOffset = offsetY + target.scrollTop;
        let firstChild = target.firstChild;
        if (g_currentItemHeight === null) {
            let nextChild = target.firstChild.nextSibling;
            g_currentItemHeight = nextChild.offsetTop - firstChild.offsetTop;
        }
        let initialMargin = firstChild.offsetTop - target.offsetTop;
        let numBefore = Math.floor((actualOffset - initialMargin) / g_currentItemHeight + 0.3);
        if (numBefore < target.childNodes.length) {
            return getDropIndexAtStartOfRun(target.childNodes[numBefore]);
        } else {
            // We're at the end
            return [-1, target.lastChild];
        }
    }
}

function onTablistDragOver(event) {
    try {
        event.preventDefault();
        var actualIndices = event.dataTransfer.getData("text").split(/,/).map((x) => parseInt(x, 10));
        var [tabIndex, newTargetNode] = getDropIndex(event, actualIndices);
        if (newTargetNode == null) {
            return;
        }
        setDragTargetIndicator(newTargetNode, tabIndex);
    } catch(ex) {
        console.log(`tabhunter: error on drag/drop over handler: ${ex}`);
    }
}

function tabsFromItems(items) {
    return items.map((item) => item.tabID);
}

function moveTabsToAnotherTab(actualIndices, targetIndex, targetTabInfo) {
    var result = {repopulate:true};
    moveTabsToAnotherTabAux(actualIndices, targetIndex, targetTabInfo, result);
    if (result.repopulate) {
        populateTabList();
    }
}

async function moveTabsToAnotherTabAux(actualIndices, targetIndex, targetTabInfo, result) {
    let targetWindowID = targetTabInfo.windowID;
    var tabItems = actualIndices.map((index) => items[index]);
    let tabIDs = tabsFromItems(tabItems);
    let moveProperties = { windowId: targetWindowID,
                           index: targetIndex };
    
    if (targetIndex == -1) {
        // move to end of last window: easy
        await browser.tabs.move(tabIDs, moveProperties);
        return;
    }
    
    var targetWindowIndex = windowCounter.index(targetWindowID);
    let startOfTargetWindowIndex = tabItems.findIndex((item) => windowCounter.index(item.windowID) >= targetWindowIndex);
    if (startOfTargetWindowIndex == -1) {
        // no source tabs on target tab's window: tab.move handles this fine
        await browser.tabs.move(tabIDs, moveProperties);
        return;
    }
    // Scenario #1, moving 5 tabs from 3 windows to right of 2 tabs on window2:
    // w1t1 w2[0] w2[1] w2[3] w3t4 => {window:W2, index:2}
    // startOfTargetWindowIndex = 1
    // postTargetTabIndex = 3
    // numberOfWindowTabsBeforeTarget = 3 - 1
    
    // Scenario #2, moving 3 tabs from 2 windows to right of 2 tabs on window2:
    // w1t1 w2[0] w2[1] => {window:W2, index:2}
    // startOfTargetWindowIndex = 1
    // postTargetTabIndex = -1
    // numberOfWindowTabsBeforeTarget = 3 - 1 == 2
    
    let postTargetTabIndex = tabItems.slice(startOfTargetWindowIndex).
       findIndex((item) => (windowCounter.index(item.windowID) > targetWindowIndex ||
                            (windowCounter.index(item.windowID) == targetWindowIndex &&
                             item.tabIndex >= targetIndex)));
    let numberOfWindowTabsBeforeTarget = (postTargetTabIndex == -1 ?
                                          tabItems.length - startOfTargetWindowIndex :
                                          postTargetTabIndex - startOfTargetWindowIndex);
    if (numberOfWindowTabsBeforeTarget == 0) {
        // source tabs on target tab's window, but only to right of target - tabs.move ok
        await browser.tabs.move(tabIDs, moveProperties);
    } else {
        // tabs.move has trouble inserting on same window to right of source tabs,
        // so workaround:
        // Move all the tabs to the end of the target window,
        // and then bounce them back to the desired slot.
        result.repopulate = false;
        moveProperties.index = -1;
        await browser.tabs.move(tabIDs, moveProperties);
        // Don't know why, but this only works if the tabbars sync up before the second move
        setTimeout(function() {
                moveProperties.index = targetIndex - numberOfWindowTabsBeforeTarget;
                browser.tabs.move(tabIDs, moveProperties).
                    then(populateTabList).
                    catch(function(err) {
                            console.log("tabhunter: moving tabs back: " + err);
                        });
            }, 1);
    }
}

function selectMovedTargetNodes(attempt, actualIndices) {
    let matchedItemIndices = actualIndices.map((index) => matchedItems.indexOf(index));
    // Is the list not yet fully built?
    if (matchedItemIndices.every((index) => index >= 0)) {
        matchedItemIndices.forEach((matchedItemIndex) => {
                tablist.childNodes[matchedItemIndex].classList.add('selected');
            });
            if (matchedItemIndices.every((index) => index >= 0)) {
                matchedItemIndices.forEach((matchedItemIndex) => {
                        tablist.childNodes[matchedItemIndex].classList.add('selected');
                    });
            } else if (attempt <= 10) {
                // Sometimes we haven't finished the various promises while updating
                // the node list, so retry
                setTimeout(selectMovedTargetNodes, attempt * 10, attempt + 1);
            } else {
                console.log(`tabhunter: didn\'t find the tabs`);
            }
    }
}

function onTablistDropHandler(event) {
    try {
        event.preventDefault();
        removeDragTargetIndicator();
        var actualIndices = event.dataTransfer.getData("text").split(/,/).map((x) => parseInt(x, 10));
        let [targetIndex, targetTabInfo] = getDropIndexWithTabInfo(event, actualIndices);
        if (targetIndex === null) {
            return;
        }
        moveTabsToAnotherTab(actualIndices, targetIndex, targetTabInfo);
    } catch(ex) {
        console.log(`tabhunter: error on drag/drop drop handler: ${ex}`);
    }
    event.preventDefault();
    event.stopPropagation();
}

function removeDragTargetIndicator() {
    if (g_currentDragTarget) {
        g_currentDragTarget.classList.remove(g_currentDragTargetClassName);
        g_currentDragTargetClassName = g_currentDragTarget = null;
    }
}

function setDragTargetIndicator(targetNode, actualIndex) {
    removeDragTargetIndicator();
    g_currentDragTargetClassName = actualIndex == -1 ? 'tabenter-after' : 'tabenter';
    (g_currentDragTarget = targetNode).classList.add(g_currentDragTargetClassName);
}

function updateButtons() {
    const selectedItems = getSelectedItemsJQ();
    var selectedItemLength = selectedItems.length;
    var matchedItemLength = matchedItems.length;
    var otherDisabled = selectedItemLength == 0;
    document.getElementById("go").disabled = selectedItemLength != 1 || matchedItemLength == 0;
    closeTabsButton.disabled = otherDisabled;
    const selectedActualIndices = selectedItems.map(elt => elt.actualIndex);
    reloadTabsButton.disabled = selectedItemLength == 0 || selectedActualIndices.some(i => items[i].discarded);
    selectAllButton.disabled = matchedItems.length == 0;
    document.getElementById("copyURL").disabled = otherDisabled;
    document.getElementById("copyTitle").disabled = otherDisabled;
    document.getElementById("copyURLTitle").disabled = otherDisabled;
    
    // showAudioButton is always enabled
    
    finishMoveToWindowButton.disabled = otherDisabled;
    discardTabsButton.disabled = otherDisabled;
    activateTabsButton.disabled = !hasDiscardedTabs || otherDisabled;

<% if ENV['TARGET'] == 'firefox' %>
    finishMoveToBookmarkButton.disabled = otherDisabled;
<% end %>
    
    var closeTabsContent = closeTabsButton.textContent;
    var newCloseTabsContent = "";
    var m = matchCloseTabs.exec(closeTabsContent);
    if (m[2] == 's') {
        if (selectedItemLength == 1) {
            newCloseTabsContent = m[1];
        }
    } else if (selectedItemLength > 1) {
        newCloseTabsContent = m[1] + 's';
    }
    if (newCloseTabsContent != "") {
        closeTabsButton.textContent = newCloseTabsContent;
    }
}

function updateURL() {
    var url = document.getElementById("url");
    var selectedItems = getSelectedItemsJQ();
    if (selectedItems.length >= 1) {
        var index = selectedItems[0].actualIndex;
        URL.value = items[index].url;
        return;
    }
    if (matchedItems.length == 1) {
        url.value = items[matchedItems[0]].url;
    } else {
        url.value = "";
    }
}

async function updateActivity() {
    var pattern = mainPattern.value;
    var text;
    if (!pattern && matchedItems.length == items.length) {
        text = `Hunting through ${items.length} tabs`;
    } else {
        text = `Matched ${matchedItems.length}/${items.length} tabs`;
    }
    if (sortBy == compareByWindowTab && g_windowInfoArray.length > 1) {
        try {
            const cwin = await browser.windows.getCurrent();
            const num = g_windowInfoArray.findIndex(w => w.id == cwin.id);
            if (num >= 0) {
                text += `. Current window #${ num + 1 }`;  // The view is 1-based...
            }
        } catch(e) {
            console.log(`QQQ: Failed to get current tab: ${ e} `);
        }
    }
    document.getElementById("activity").innerText = text;
}

function doRemoveFromList(selectedItems, cb) {
    var clientWidth = selectedItems[0].clientWidth - 100;
    const widthToTraverse = 0.8 * clientWidth;
    const timeForAnimation = 20; //ticks
    const a = 2.0 * widthToTraverse / (timeForAnimation * timeForAnimation);
    const delay = 10;
    let dx = 0;
    let doDeleteItems = function(i) {
        if (i > timeForAnimation) {
            for (let item of selectedItems) {
                item.parentNode.removeChild(item);
            }
            cb();
        } else {
            // i^2 - (i - 1)^2 = - (-2i + 1) == 2i - 1
            let delta = (a / 2.0) * (2 * i - 1);
            dx += delta;
            for (let item of selectedItems) {
                item.style.paddingLeft = (20 + dx) + 'px';
                item.style.backgroundPositionX = dx + 'px';
            }
            setTimeout(doDeleteItems, delay, i + 1);
        }
    };
    doDeleteItems(1);
}


// Tabs: save [title, url, window#id, tab#id, tab#index, tab#favIconUrl]
function doCloseTabsButton() {
    var selectedItems = getSelectedItemsJQ();
    if (selectedItems.length == 0) {
        return;
    }
    doRemoveFromList(selectedItems, function() {
            let tabIds = selectedItems.map(function(selectedItem) {
                    return items[selectedItem.actualIndex].tabID;
                });
            let removeTabError = function(err) {
                let msg = "Error removing tab: ";
                if (typeof(err) == "string") {
                    msg += err;
                } else {
                    msg += err.message;
                }
                alert("Error removing tab: " + msg);
            }
            let removeTabOK = function() {
                setTimeout(populateTabList, 10);
            }
            browser.tabs.remove(tabIds).then(removeTabOK, removeTabError);
        });
}

function doSelectAll() {
    selectedIndex = 0;
    lastClickedIndex = matchedItems.length - 1;
    selectRange(selectedIndex, lastClickedIndex);
    updateButtons();
}

function gatherText(fn) {
    var selectedItems = getSelectedItemsJQ();
    if (selectedItems.length == 0) {
        return;
    }
    var textPieces = selectedItems.map(function(selectedItem) {
        return fn(items[selectedItem.actualIndex]);
    });
    return textPieces.join("\n");
}

function setClipboard(text) {
    try {
        textarea.style.display = "block";
        textarea.textContent = text;
        textarea.select();
        document.execCommand("cut");
    } catch(ex) {
        console.log("tabhunter: Error setting/copying text: " + text);
    }
    textarea.style.display = "none";
}

function doCopyURLButton() {
    var text = gatherText(function(item) { return item.url; });
    setClipboard(text);
}

function doCopyTitleButton() {
    var text = gatherText(function(item) { return item.title; });
    setClipboard(text);
}

function doCopyURLTitleButton() {
    var text = gatherText(function(item) { return item.url + '-' + item.title; });
    setClipboard(text);
}

function onMainPatternMouseDown(event) {
    let msg = document.getElementById("activity").innerText;
    let extra = ". Press the '<up> Search Text in Tabs' button to edit the url/title pattern";
    if (msg.indexOf(extra) == -1) {
        msg += extra;
    }
    document.getElementById("activity").innerText = msg;
    setTimeout(async () => {
        await updateActivity();
      }, 15 * 1000);
    event.stopPropagation();
    event.preventDefault();
    return false;
}
    

function disableSearchWidgets() {
    mainPattern.readOnly = true;
    mainPattern.addEventListener('mouseup', onMainPatternMouseDown, false);
    showAudioButton.disabled = true;
}

function enableSearchWidgets() {
    mainPattern.readOnly = false;
    showAudioButton.disabled = false;
    mainPattern.removeEventListener('mouseup', onMainPatternMouseDown, false);
}

function showSearchTextArea() {
    hideWindowMover();
    showSearchTextAreaButton.removeEventListener("mouseup", showSearchTextArea, false);
    showSearchTextAreaButton.addEventListener("mouseup", hideSearchTextArea, false);
    disableSearchWidgets();
    $("div#searchTextArea").removeClass("hide").addClass("show");
    $("span#showSearchText").removeClass("show").addClass("hide");
    $("span#hideSearchText").removeClass("hide").addClass("show");
    prepareForSearching();
}

async function prepareForSearching() {
    originalMatchedItems = [].concat(matchedItems);
    tabIDsForSearching = [];
    for (let i = matchedItems.length - 1; i >= 0; i -= 1) {
        let index = matchedItems[i];
        let item = items[index];
        let tabID = item.tabID;
        if (item.discarded) {
            matchedItems.splice(i, 1);
        } else if (item.url.indexOf("about:") == 0) {
            matchedItems.splice(i, 1);
        } else if (tabsWithText.has(tabID)) {
            // nothing to do
        } else {
            try {
<% if ENV['TARGET'] == 'firefox' %>
                await browser.tabs.executeScript(tabID, { file: "/content/matchText.js",
                            runAt: "document_end"} );
<% else %>
                    await chrome.scripting.executeScript({
                        target: { tabId: tabID},
                        files: ["/content/matchText.js"]
                    });
<% end %>
                tabIDsForSearching.unshift([tabID, index]);
            } catch(ex) {
                matchedItems.splice(i, 1);
                if (ex.toString().indexOf("Missing host permission for the tab") == -1) {
                    console.log(`tabhunter: error trying to inject search script into tab ${item.title}: ${ex}`);
                }
            }
        }
    }
    makeListFromMatchedItems(function() { 
            sessionMatchedItems = [].concat(matchedItems);
        });
}

function hideSearchTextArea() {
    $("div#searchTextArea").removeClass("show").addClass("hide");
}

function doHideSearchTextAreaDependencies() {
    showSearchTextAreaButton.removeEventListener("mouseup", hideSearchTextArea, false);
    showSearchTextAreaButton.addEventListener("mouseup", showSearchTextArea, false);
    enableSearchWidgets();
    $("span#showSearchText").removeClass("hide").addClass("show");
    $("span#hideSearchText").removeClass("show").addClass("hide");
    matchedItems = originalMatchedItems;
    makeListFromMatchedItems();
}

function onSearchTextAreaChanged(mutationList, observer) {
    mutationList.forEach((mutation) => {
            if (mutation.type == 'attributes' && searchTextArea.classList.contains('hide')) {
                doHideSearchTextAreaDependencies();
            }
        });
}

function showWindowMover() {
    //TODO: If we're going form 'pattern' to 'more', do the end-pattern restore stuff
    moveToWindowButton.removeEventListener("mouseup", showWindowMover, false);
    moveToWindowButton.addEventListener("mouseup", hideWindowMover, false);
    $("div#moveToWindowArea").removeClass("hide").addClass("show");
    $("span#showMoreActions").removeClass("show").addClass("hide");
    $("span#hideMoreActions").removeClass("hide").addClass("show");
    populateWindowPicker();
<% if ENV['TARGET'] == 'firefox' %>
    if (!g_bookmarkList) {
        // Watch out -- this one is async
        populateBookmarkPicker();
    }
<% end %>
}

function hideWindowMover() {
    moveToWindowButton.removeEventListener("mouseup", hideWindowMover, false);
    moveToWindowButton.addEventListener("mouseup", showWindowMover, false);
    $("div#moveToWindowArea").removeClass("show").addClass("hide");
    $("span#hideMoreActions").removeClass("show").addClass("hide");
    $("span#showMoreActions").removeClass("hide").addClass("show");
}

function populateWindowPicker() {
    try {
    while (selectWindowTargetWidget.lastChild) {
        selectWindowTargetWidget.removeChild(selectWindowTargetWidget.lastChild);
    }
    var i = 0;
    for (var windowInfo of g_windowInfoArray) {
        i += 1;
        let optionElement = document.createElement("option");
        optionElement.value = windowInfo.id;
        optionElement.text = `[${i}] ${getWindowTitle(windowInfo)}`;
        if (i == 1) {
            optionElement.selected = true;
        }
        selectWindowTargetWidget.appendChild(optionElement);
    }
    } catch(ex) { console.log(ex); }
}

function getWindowTitle(windowInfo) {
<% if ENV['TARGET'] == 'firefox' %>
    return windowInfo.title;
<% else %>
    return windowInfo.tabs[0].title
<% end %>
}

function TabChanger(tabIDs, opLabel, op, actualItems) {
    this.index = -1;
    this.tabIDs = tabIDs;
    this.op = op;
    this.opLabel = opLabel;
    this.actualItems = actualItems;
}

TabChanger.prototype = {
    changeTabError: function(error) {
        let s = `Error: ${this.opLabel}: tab ${this.actualItems[this.index].title}: ${error}`;
        setStatusBarMessage(s);
        console.log("tabhunter: " + s);
    },
    next: function() {
        if (this.index >= this.tabIDs.length - 1) {
            setStatusBarMessage(`${this.opLabel} successful`);
            setTimeout(populateTabList, 10);
            return;
        }
        this.index += 1;
        this.op(this.tabIDs[this.index], this.next.bind(this), this.changeTabError.bind(this));
    }
};    

function discardTheTabs() {
    var selectedItems = getSelectedItemsJQ();
    var selectedActualIndices = selectedItems.map(function(elt) { return elt.actualIndex });
    var actualItems = selectedActualIndices.map((i) => items[i]).filter((item) => !item.discarded && item.tabID != g_activeTab);
    var tabIDs = actualItems.map((item) => item.tabID);
    if (tabIDs.length == 0) {
        let s = "All selected items are already discarded";
        setStatusBarMessage(s);
        console.log("Tabhunter: " + s);
        return;
    }
<% if ENV['TARGET'] == 'firefox' %>
    let discardTabError = function(err) {
        var msg = "Error discarding tab: ";
        if (typeof(err) == "string") {
            msg += err;
        } else {
            msg += err.message;
        }
        setStatusBarMessage(msg)
        console.log("Tabhunter: " + msg);
    }
    let discardTabOK = function() {
        setStatusBarMessage("Discard successful");
        setTimeout(populateTabList, 10);
    }
    browser.tabs.discard(tabIDs).then(discardTabOK, discardTabError);
<% else %>
    new TabChanger(tabIDs, "discard", function(tabID, onResolve, onReject) {
        browser.tabs.discard(tabID, onResolve)
    }, actualItems).next();
<% end %>
}

function activateTheTabs() {
    var selectedItems = getSelectedItemsJQ();
    var selectedActualIndices = selectedItems.map(function(elt) { return elt.actualIndex });
    var actualItems = selectedActualIndices.map((i) => items[i]).filter((item) => item.discarded);
    var tabIDs = actualItems.map((item) => item.tabID);
    if (tabIDs.length == 0) {
        let s = "All selected items are already activated";
        setStatusBarMessage(s)
        console.log("Tabhunter: " + s);
    } else {
        new TabChanger(tabIDs, "activate", function(tabID, onResolve, onReject) {
              browser.tabs.reload(tabID).
                then(onResolve).
                catch(onReject);
              }, actualItems).next();
    }
}

function doReloadTabs() {
    var selectedItems = getSelectedItemsJQ();
    var selectedActualIndices = selectedItems.filter(item => !item.discarded).map(function(elt) { return elt.actualIndex });
    var actualItems = selectedActualIndices.map((i) => items[i]);
    var tabIDs = actualItems.map((item) => item.tabID);
    if (tabIDs.length == 0) {
        let s = "No selected items to reload";
        setStatusBarMessage(s)
        console.log("Tabhunter: " + s);
    } else {
        new TabChanger(tabIDs, "reload", function(tabID, onResolve, onReject) {
                browser.tabs.reload(tabID, { bypassCache: true }).
                then(onResolve).
                catch(onReject);
              }, actualItems).next();
    }
}

function doMoveToWindowButton() {
    let reportErr = function(err) {
        console.log("tabhunter: doMoveToWindowButton: " + err);
    };
    let options = selectWindowTargetWidget.selectedOptions;
    if (options.length == 0) {
        alert("No target window to move tabs to");
        return;
    }
    let targetWindowID = parseInt(options.item(0).value, 10);
    let targetIndex = 0;
    g_windowInfoArray.forEach(function(windowInfo) {
        if (windowInfo.id == targetWindowID) {
            targetIndex = windowInfo.tabs.length;
        }
    });
    let selectedItems = getSelectedItemsJQ();
    let itemsToMove = selectedItems.map(function(selectedItem) { return items[selectedItem.actualIndex]; });
    let tabIds = itemsToMove.map(function(item) { return item.tabID; });
    
    browser.tabs.move(tabIds,
                      {windowId: parseInt(targetWindowID, 10),
                       index: targetIndex
                      }
                     ).then(function(tabsList) {
                         populateTabList();
                     }).catch(reportErr);
}

<% if ENV['TARGET'] == 'firefox' %>
function populateBookmarkPicker() {
    try {
        g_bookmarkList = [];
        var i = 0;
        let extractTitlesFromItem = function(bookmarkItem, parentPath) {
            if (bookmarkItem.type != "folder") {
                return;
            }
            var fullPath;
            var nextPath;
            if (bookmarkItem.title) {
                i += 1;
                fullPath = parentPath + bookmarkItem.title;
                nextPath = fullPath + "/";
                let optionElement = document.createElement("option");
                optionElement.value = bookmarkItem.id;
                optionElement.text = `[${i}] ${fullPath}`;
                if (i == 1) {
                    optionElement.selected = true;
                }
                selectBookmarkTargetWidget.appendChild(optionElement);
                g_bookmarkList.push(bookmarkItem.title);
            } else {
                nextPath = parentPath;
            }
                
            if (bookmarkItem.children) {
                for (var child of bookmarkItem.children) {
                    extractTitlesFromItem(child, nextPath);
                }
            }
        };
        let getBookmarkTree = function(items) {
            extractTitlesFromItem(items[0], "");
        }
        let reportErr = function(err) {
            console.log("tabhunter: error getting bookmarks: " + err);
        };
        browser.bookmarks.getTree().then(getBookmarkTree, reportErr);
    } catch(ex) { console.log(ex); }
}

function doMoveToBookmarkButton() {
    try {
    let options = selectBookmarkTargetWidget.selectedOptions;
    if (options.length == 0) {
        alert("No target bookmark to move tabs to");
        return;
    }
    let targetBookmarkID = options.item(0).value;
    let selectedItems = getSelectedItemsJQ();
    let itemsToMove = selectedItems.map(function(selectedItem) { return items[selectedItem.actualIndex]; });
    let urls = itemsToMove.map(function(item) { return item.url; });
        let index = -1;
        var reportErr, moveNextURL;
    reportErr = function(err) {
        console.log("tabhunter: error creating bookmark: " + err);
    };
    moveNextURL = function(newBookmark) {
        if (index >= urls.length - 1) {
            let s = `Moved ${pluralize(urls.length, "tab")} to bookmark ${options.item(0).text}`;
            setStatusBarMessage(s);
            return;
        }
        index += 1;
        browser.bookmarks.create({
            parentId: targetBookmarkID,
            url: urls[index]
        }).then(moveNextURL, reportErr);
    };
    moveNextURL(null);
    } catch(ex) { console.log(ex); }
}
<% end %>

function doHandleAudioCheckbox() {
    g_showAudio = showAudioButton.checked;
    browser.storage.local.set({"showAudio": g_showAudio});
    onPatternChanged(null, false);
}

function doHideDiscardedTabsCheckbox() {
    g_hideDiscardTabs = hideDiscardedTabsButton.checked;
    browser.storage.local.set({"hideDiscardTabs": g_hideDiscardTabs});
    onPatternChanged(null, false);
}

function doGoButton() {
    var selItems = getSelectedItemsJQ();
    if (selItems.length == 1 || matchedItems.length == 1) {
        doVisitSelectedURL();
    }
}

function getModifierMask(event) {
    return (0 |
            (event.shiftKey ? SHIFT_KEY : 0 ) |
            (event.ctrlKey ? CTRL_KEY : 0 ) |
            (event.altKey ? ALT_KEY : 0 ) |
            (event.metaKey ?  CTRL_KEY: 0 ) |
            (event.commandKey ? CTRL_KEY : 0 ));
}

// Things for dealing with searching tabs

function onSearchTextFieldKeyup(event, calledFromInit) {
    if (typeof(calledFromInit) === "undefined") calledFromInit = false;
    if (event.keyCode == 13 && getModifierMask(event) == 0) {
        event.preventDefault();
        event.stopPropagation();
        if (!searchTextSearchButton.disabled && searchTextField.value.length > 0) {
            doSearchForTheText(event);
        }
        return true;
    }
    return false;
}

function onSearchTextFieldChanged(event, calledFromInit) {
    enableSearchTextButton(event.target);
}

function enableSearchTextButton(field) {
    searchTextSearchButton.disabled = (field.value.length == 0);
}

function setSearchButtonsStatus(disabledStatus) {
    searchTextPauseButton.disabled = disabledStatus;
    searchTextCancelButton.disabled = disabledStatus;
}

// later: remove all the discarded tabs...
function doSearchForTheText(event) {
    if (searchTextField.value.length == 0) {
        return;
    }
    let continueFunc = function() {
        browser.storage.local.set({searchTextField: searchTextField.value}).then(() => {}, (err) => {
                console.log(`tabhunter: failed to set item[searchTextField] : ${err}`);
            });
        searchTextProgressBar.max = tabIDsForSearching.length;
        searchTextProgressBar.value = 0;
        searchTextPauseNow = searchTextCancelNow = false;
        setSearchButtonsStatus(false);
        currentSearcher = new Searcher(tabIDsForSearching, searchTextField.value);
        currentSearcher.search(0);
    };
    if (sessionMatchedItems.length > matchedItems.length) {
        matchedItems = [].concat(sessionMatchedItems);
        makeListFromMatchedItems(function() {
                setTimeout(continueFunc, 1);
            });
    } else {
        continueFunc();
    }
}

function Searcher(tabIDsForSearching, pattern) {
    this.pattern = pattern;
    this.tabIDsForSearching = tabIDsForSearching;
    this.successesByTabID = new Set();
    this.interruptedIndex = -1;
}

Searcher.prototype = {
  search: function(i) {
        if (!('tabIDsForSearching' in this)) {
            console.log(`Not looking at a searcher: ${this.__proto__}`);
            return;
        } else if (i >= this.tabIDsForSearching.length) {
            makeListFromMatchedItems(function () {
                    setSearchButtonsStatus(true);
                });
            //XXX: Put this in a status bar
            //console.log(`Matched ${this.successesByTabID.size} hits`);
            return;
        } else if (searchTextPauseNow) {
            this.interruptedIndex = i;
            makeListFromMatchedItems();
            return;
        } else if (searchTextCancelNow) {
            searchTextProgressBar.value = 0;
            makeListFromMatchedItems(function () {
                    setSearchButtonsStatus(true);
                });
            return;
        }
        let [tabID, actualIndex] = this.tabIDsForSearching[i];
        let payload = { matchedItemIndex: i, actualIndex: actualIndex, tabID: tabID, pattern: this.pattern };
        let response = browser.tabs.sendMessage(tabID, payload);
        response.then((message) => {
                if (!message.result) {
                    let actualIndex = message.actualIndex;
                    let matchedItemsIndex = matchedItems.findIndex((v) => v == actualIndex);
                    if (matchedItemsIndex == -1) {
                        console.log(`tabhunter: can\'t find actualIndex:${actualIndex} in matchedItems:${matchedItems}`);
                    } else {
                        matchedItems.splice(matchedItemsIndex, 1);
                    }
                    for (let item of Array.from(tablist.childNodes)) {
                        if (item.actualIndex == actualIndex) {
                            item.parentNode.removeChild(item);
                            break;
                        }
                    }
                } else {
                    this.successesByTabID.add(message.tabID);
                    let item = Array.from(tablist.childNodes).find((item) => item.actualIndex == actualIndex);
                    if (item) {
                        item.classList.add('selectedFade');
                    }
                }
                searchTextProgressBar.value += 1;
                setTimeout(this.search.bind(this), 1, i + 1);
            }).catch((err) => {
                    console.log(`tabhunter: search result failed: ${err}`);
                    searchTextProgressBar.value += 1;
                    setTimeout(this.search.bind(this), 1, i + 1);
                });
    },
    
  resume: function() {
        if (this.interruptedIndex == -1) {
            console.log(`tabhunter: No search to resume`);
            return;
        }
        setSearchButtonsStatus(false);
        let i = this.interruptedIndex;
        this.interruptedIndex = -1;
        this.search(i);
    },

  inPausedSession: function() {
        return this.interruptedIndex > -1;
    },

  __EOT__: null
}

function doSearchTextPause(event) {
    let button = event.target;
    if (button.innerText == "Pause") {
        searchTextPauseNow = true;
        button.innerText = "Resume";
    } else {
        button.innerText = "Pause";
        doSearchTextResume();
    }
    
}

function doSearchTextCancel(event) {
    searchTextCancelNow = true;
    if (currentSearcher.inPausedSession()) {
        doSearchTextResume();
    }
}

function doSearchTextResume() {
    searchTextPauseNow = false;
    currentSearcher.resume();
}

return {
    init: function () {
        return init();
    },
    reloadPrefsAndMatches: getCloseOnGoPref,
    __BOSCO__ : null
};


<% if ENV['TARGET'] == 'firefox' %>
// For some reason this function can't be loaded externally.
// Copyright info:
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license MIT license
 */

function RGBColor(color_string) {
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
          re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*\d{1,3}\)$/,
            example: ['rgba(123, 234, 45, 1)', 'rgba(255,234,245, 0)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return "rgb(" + this.r + ', ' + this.g + ', ' + this.b + ")";
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }
}
<% end %>

});

var thMain = null;
$(document).ready(function() {
  thMain = thMainFunc();
  thMain.init();
});

